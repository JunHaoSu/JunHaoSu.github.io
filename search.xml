<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Try-with-Resources]]></title>
    <url>%2F2019%2F07%2F24%2FTry-with-Resources%2F</url>
    <content type="text"><![CDATA[Java语法糖是一种在不影响功能的情况下为程序员提供的便捷的语法使用方式. Tye-with-Resources就是这样一个用来便捷的在try语句块中申请和释放资源的语法使用方式. 通过这个语法糖,可以有效的避免在finally中忘记释放资源的情况.类似的思想在Python的with语法中也有体现.推荐一个IDEA插件,sonarlint.通过sonarlint的只能提示,我们可以改正很多的不好的编码习惯. 资源什么是资源,对于非内存的操作,比如磁盘,比如网络等其他设备.都有一个临界资源的概念.什么是临界资源.在操作系统知识体系中,把一次只能由一个进程使用的资源称为临界资源,所以所有的进程使用这些资源的时候都是互斥的.那么我们在编程的时候,一定要注意临界资源的申请和释放.]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两个有序数组的中位数]]></title>
    <url>%2F2019%2F04%2F30%2F%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例 1:1234nums1 = [1, 3]nums2 = [2]则中位数是 2.0 示例 2:1234nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5 思路在两个有序数组中找到中位数还没怎么想过，先回顾一下中位数的定义，一个有序数组，如果是奇数个，中位数是最中间那个数，如果是偶数个，中位数是中间两个数的平均数，拿到题的第一反应是组合成一个有序数组，但是时间复杂度告诉自己不允许这个做。那么还真的必须处理两个有序数组的中位数。为了方便，我们统一将中位数看成（m+n+1)/2和（m+n+2)/2的平均数，如果m+n是奇数，则（m+n+1)/2和（m+n+2)/2是同一个位置。 K是m+n的中间值，如何在两个有序数组中找到K元素呢?，使用i,j来标记两个数组的起始位置。边界条件如下： 某一个数组空白，直接取另一个数组的中位数 K=1，即当两个数组只有一个数字的时候，且取偶数个的左边较小的数字，即比较num1和num2的i，j位置上的数就可以了。 我们使用二分法对数组进行搜索，首先对K二分，分别在num1和num2中查找K/2个单元存在第K/2个数吗？如果存在，取出来，不存在就赋最大值 代码123456789101112131415161718public class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int m = nums1.length, n = nums2.length, left = (m + n + 1) / 2, right = (m + n + 2) / 2; return (findKth(nums1, 0, nums2, 0, left) + findKth(nums1, 0, nums2, 0, right)) / 2.0; &#125; int findKth(int[] nums1, int i, int[] nums2, int j, int k) &#123; if (i &gt;= nums1.length) return nums2[j + k - 1]; if (j &gt;= nums2.length) return nums1[i + k - 1]; if (k == 1) return Math.min(nums1[i], nums2[j]); int midVal1 = (i + k / 2 - 1 &lt; nums1.length) ? nums1[i + k / 2 - 1] : Integer.MAX_VALUE; int midVal2 = (j + k / 2 - 1 &lt; nums2.length) ? nums2[j + k / 2 - 1] : Integer.MAX_VALUE; if (midVal1 &lt; midVal2) &#123; return findKth(nums1, i + k / 2, nums2, j, k - k / 2); &#125; else &#123; return findKth(nums1, i, nums2, j + k / 2, k - k / 2); &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[梯度下降法理解]]></title>
    <url>%2F2019%2F04%2F28%2F%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[概念回顾在理解梯度下降法之前，我们先来回顾以前学习的数学知识 微分微分的意义是什么？我们来复习一下高数知识。 函数图像某切点的斜率 函数的变化率 常用的微分]]></content>
      <tags>
        <tag>数学</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无重复字符的最长子串]]></title>
    <url>%2F2019%2F04%2F27%2F%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1:123输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2:123输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3:1234输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 思路这种字符串题目首先想到的思路是从左向右进行扫描，按照人脑的想法想法一步一步的向后扫，所以我们可以维持一个滑动窗口，每当出现一个重复的字母左界后移，没有就右界后移，每次循环的窗口都进行比较，取最大的数作为结果。 代码123456789101112131415161718192021222324class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; //定义结果 int result = 0; //滑动窗口的左右[i,j) int i=0,j=0; //定义一个Set，保证每个字母只出现一次 Set&lt;Character&gt; set = new HashSet&lt;&gt;(); //防止过界 while(i&lt;s.length() &amp;&amp; j&lt;s.length())&#123; //如果当前字符在set中不存在 if(!set.contains(s.charAt(j)))&#123; //将当前字符加入set并将右界后移 set.add(s.charAt(j++)); //取所有出现窗口的最大值 result = Math.max(result,j-i); &#125;else&#123; //如果出现重复的字符，将左界后移一位 set.remove(s.charAt(i++)); &#125; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两数相加]]></title>
    <url>%2F2019%2F04%2F27%2F%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[题目给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例：123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 思路这道题的思路非常简单，因为是链表而且低位是表头，所以直接按照加法的思路，从低位向高位进行进位就成。要对头结点进行操作时，为了避免两个输入链表同时为空，考虑创建哑节点dummy使用dummy-&gt;next表示真正的头节点。 代码123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; //新建哑元节点 ListNode dummy = new ListNode(-1); //从哑元节点后开始作为头结点,游标初始化处于头结点前 ListNode cur = dummy; //进位初始化为0 int carry = 0; //两条链都为零结束循环 while(l1 != null||l2 != null)&#123; //链1节点不为空时值给num1，为空时num1=0， num2同理 int num1 = l1 == null ? 0 : l1.val; int num2 = l2 == null ? 0 : l2.val; //将低位的进位和两个数相加 int sum = num1 + num2 + carry; //大于十则产生进位，carry=1,否则为0 carry = sum &gt;= 10 ? 1 : 0; //处理当前节点，值为个位尾数 cur.next = new ListNode(sum % 10); //游标后移 cur = cur.next; //如果l1不为空,l1后移，l2同理 if(l1 != null) l1 = l1.next; if(l2 != null) l2 = l2.next; &#125; //如果两条链都为零,并且有进位产生，新建一个高位进位节点就行 if (carry == 1) cur.next = new ListNode(1); //返回链，头结点是哑元节点后的节点 return dummy.next; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两数之和]]></title>
    <url>%2F2019%2F04%2F27%2FTwoSum%2F</url>
    <content type="text"><![CDATA[坚持就是胜利，开始刷题之旅 题目给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例:12345给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 思路读懂这道题后的第一反应就是暴力向后搜索。但是这样的复杂度是O(n^2),肯定没有这么简单。只能通过空间来换时间，那么有什么查询方式是O(1)呢？第一反应是散列查找，也就是哈希查找。在java中。有HashMap类可以实现这个需求，那么代码可以是这个样子 代码解法一1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; //初始化一个int对应int的hashmap HashMap&lt;Integer, Integer&gt; m = new HashMap&lt;Integer, Integer&gt;(); //初始化结果数组 int[] res = new int[2]; //将题目给定的数组放入hashmap中 for (int i = 0; i &lt; nums.length; i++) &#123; m.put(nums[i], i); &#125; //开始搜索 for (int i = 0; i &lt; nums.length; i++) &#123; //搜索值等于和减去当前值 int t = target - nums[i]; //在hashmap中搜索并且保证存在而且不等于当前值 if (m.containsKey(t) &amp;&amp; m.get(t) != i) &#123; //对结果进行赋值，搜索到所以退出搜索 res[0] = i; res[1] = m.get(t); break; &#125; &#125; return res; &#125;&#125;; 提交上述代码，会发现内存消耗很大，时间也只是9ms超过了80%的人。一定有更优的解法。百度后发现可以将两个操作合二为一。上述解法先是将数组放入hashmap中，然后再进行查找。可不可以边放边找呢？先全部放入就是拿到前面的数去找后面的数。边放边找就是拿着后面的数去找前面的数。仔细想想，确实是这个道理。那么试试？？ 解法二123456789101112131415161718192021class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; //初始化一个int对应int的hashmap HashMap&lt;Integer, Integer&gt; m = new HashMap&lt;Integer, Integer&gt;(); //初始化结果数组 int[] res = new int[2]; //开始查找 for (int i = 0; i &lt; nums.length; i++) &#123; //如果hashmap中存在和减去当前数的数字 if(m.containsKey(target - nums[i]))&#123; //赋值，表示查找到，用后数找前数，所以需要换一下位置 res[1]=i; res[0]=m.get(target - nums[i]); break; &#125; //关键，每次循环都要放一个数到hashmap中，在查找中，拿着前数总是找不到后数的，因为还没有放进去，但是总会循环到后数，拿着后数的时候，前数已经放进去了，总是能找到的。所以这个方法很精妙，没有问题。 m.put(nums[i], i); &#125; return res; &#125;&#125; 上述方法快了1ms,内存消耗也少了。]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存区域]]></title>
    <url>%2F2019%2F04%2F23%2FJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[Java内存分布虽然对于入门的Java初学者来说是透明的，上课念PPT的老师也永远不会跟你提及这些概念，顶多在继承封装多态上让你背一些概念性的东西，但是都说知其然知其所以然，作为Java虚拟机知识体系基础的Java内存是如何进行管理的呢？理解了Java虚拟机的运行原理，对于排除代码BUG和程序性能优化有非常大的好处 程序计数器类似于CPU内部的PC寄存器，保存着字节码指令地址．程序需要通过程序计数器的值来选取下一条需要执行的字节码指令．程序的分支，跳转，循环，异常处理，线程恢复都得靠程序计数器来完成．程序计数器保证了JAVA各线程执行时的井然有序，所以是线程私有的，各个线程独立存储． 如果执行的是Java方法，程序计数器存储的是正在执行的字节码指令的地址 如果正在执行的是Native方法，程序计数器为空(Undefined) 此内存区域是唯一一个没有规定任何OutOfMemoryError情况的区域 Java虚拟机栈Java虚拟机栈同样是线程私有的，是方法执行时的结构．描述的是方法执行时的内存模型．每个方法执行时都会创建栈帧，用于存储方法的信息．方法的调用和返回过程，对应着栈帧的入栈和出栈过程 栈帧包含信息包括局部变量表，操作数栈，动态链接，和方法的返回地址 如果线程请求的栈深度超过了虚拟机允许的深度，会抛出StackOverflowError异常，如果允许动态扩展的栈在扩展时无法申请到足够的内存，会抛出OutOfMemoryError异常。 局部变量表简介局部变量表存放方法参数和方法内部局部变量。在编译成Class文件时，在方法的Code属性中的max_locals数据项中就确定了该方法局部变量表的最大容量，局部变量表以变量槽（Slot）为最小单位。详细内容会再进行专门介绍。 操作数栈简介操作数栈是一个后进先出的栈结构，最大深度在编译时写入Code属性中的max_stacks数据项中。方法开始执行时为空，方法内部的算术运算或者调用其他方法的时候就是通过操作数栈来进行参数传递的。与汇编语言中的CPU栈概念模型类似。 动态链接简介每个栈帧都包含指向运行时常量池中该栈帧所属方法的引用，Class文件的常量池中存在大量的符号引用，字节码中方法调用指令就以常量池中指向方法的符号引用作为参数。 在类加载阶段转化为直接引用，这种转化成为静态解析。 在每一次运行期间转化为直接引用，这部分成为动态链接。 方法返回地址简介方法一定是会执行完成的。有两种方式结束方法的执行。一是正常结束，调用者的PC计数器的值可以作为返回地址。二是异常退出，返回地址通过异常处理器表来完成。 方法退出等同于把当前栈帧出栈。可能执行的操作有，恢复上层方法的局部变量表和操作数栈，将返回值写入调用者栈帧的操作数栈，调整PC计数器的值指向方法调用指令的后一条。 本地方法栈本地方法栈与虚拟机栈发挥作用相似，其中执行的是虚拟机使用到的Native方法。各个虚拟机可能会不同，Sun HotSpot虚拟机就直接将本地方法栈和虚拟机栈合二为一。与虚拟机栈相同，本地方法栈也会抛出StackOverflowError和OutMemoryError异常。 Java堆Java堆是所有new对象的存储地，是Java虚拟机所管理内存中最大的一块。后续将要学习的内存回收算法就是与这块内存有关的。Java堆是所有线程共享的内存区域。Java虚拟机规范描述：所有的对象实例以及数组都要在堆上进行分配。 Java堆是GC管理的主要区域，可以细分为新生代，老年代。新生代是那种频繁被创建和销毁的对象的存放地，可能每次进行垃圾收集时就会有大批量的对象被清除。老年代的对象则存活率高，新生代的对象如果达到了老年代的标准，也会被划分到老年代，大对象创建时也会直接分配到老年代。具体细节会在GC回收中再总结。 方法区方法区和堆一样也是线程共享的区域。用于存储已经被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据，比如spring 使用IOC或者AOP创建bean时，或者使用cglib，反射的形式动态生成class信息等）。Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不进行垃圾搜集。这个区域的垃圾搜集行为比较少见。方法区不够大时，会抛出OutOfMemoryError异常。类信息如下，详细内容会在Java类加载机制中介绍。 类信息 类型全限定名。 类型的直接超类的全限定名（除非这个类型是java.lang.Object，它没有超类）。 类型是类类型还是接口类型。 类型的访问修饰符（public、abstract或final的某个子集）。 任何直接超接口的全限定名的有序列表。 类型的常量池。 字段信息。 方法信息。 除了常量意外的所有类（静态）变量。 一个到类ClassLoader的引用。 一个到Class类的引用。 运行时常量池Class文件中有一项信息存储编译期生成的各种字面量和符号引用，也就是常量池，这部分内容在类加载后会进入方法区的运行时常量池存放。运行时常量池具有动态性，并不要求运行时常量池严格和Class文件中的常量池内容一致，运行期间也能将新的常量放入池中，比如String类的intern()方法. 运行时常量池隶属于方法区，同样在内存不够大时抛出OutOfMemory异常。]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>内存模型</tag>
      </tags>
  </entry>
</search>

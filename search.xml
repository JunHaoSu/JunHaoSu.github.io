<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设计模式——过度设计的例子]]></title>
    <url>%2F2020%2F05%2F04%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%BF%87%E5%BA%A6%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%BE%8B%E5%AD%90%2F</url>
    <content type="text"><![CDATA[设计模式并没有什么好或者不好，而是是否合适。在实际的代码编写过程中，经常会遇到各种各样的设计问题，如何去根据业务安排好逻辑，那些逻辑应该合为一类，是否符合开闭原则，在今后的需求实现中是否达到了易扩展易维护的要求，都是我们在设计代码过程中需要思考的问题。 本篇博客主要记录我因为一次死板照抄设计模式，写出了过度设计的代码，得到高手的指正后引发了我的一系列思考。 业务需求业务大致是这样的，我们需要定时对数据库的数据进行抽取，然后通过一系列计算得到大量的报表字段，拿到需求时这些报表字段多且杂，所以我依照业务意义对他们进行了分类，抽出计算所有字段需要的公用数据到抽象父类中。之后对将同一类的字段封装进一个子类中，得到了数个子类。 封装的目的是，同一类字段的计算可以使用相同的数据库原始数据，这样不同的字段计算可以共用代码和数据，减少了请求数据库的次数。 那么定时器每次执行的时候如何同时优雅的让所有的子类都执行了。在学习设计模式的时候，我首先想到了责任链，于是，运用责任链模式以及Spring的结合，让链自动初始化，并按照顺序执行，完美。 设计问题那么问题来了，责任链的应用场景多为流程自动化。这个需求并没有严格的先后顺序问题，只是保证所有的子类都执行一遍。如果其他的同事需要新加一个类，对我这样的设计不熟悉，没有严格的对每一个子类添加@Order，那么责任链的初始化就会出问题。甚至如果需要在中间插入一节，那么后续所有节点的Order数值都要修改，多麻烦啊。不符合开闭原则。 详见文章 设计模式——责任链模式 改进点回归需求，如何让所有的子类都执行一边，for循环不就好了吗？去掉链的初始化方法，去掉了调用链头0号节点的方法。新加一个for循环，循环所有的子类，执行每个子类的计算方法即可。只有最适合的设计，没有最好的设计。 相比责任链的设计，这个方法更加符合开闭原则，新加节点直接添加类即可，唯一的要求是需要继承父类，之后Spring会自动的将他加入参加for循环的bean。 反思为什么会造成过度设计呢？原因涵盖各个方面，最主要还是设计模式运用的少，类似于练武，只会一招一式的模仿，未能融会贯通，达到无招胜有招的境界。 解决方法就是多思考，多练习，幸好刚成为程序员，有大佬指点迷津，能在很早的阶段纠正想法上的错误。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pom文件结构详解]]></title>
    <url>%2F2020%2F04%2F07%2Fpom%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[maven是Java使用最多的构建工具。是java程序员必须掌握的一门技能。在实际的企业开发中，需要大量的依赖现有包的情况，所以学好maven对项目工程管理至关重要。本篇文章就现来详细学习pom文件的结构。 POM文件pom文件是maven工程的核心文件，在这个文件中申明工程信息，描述项目构建，配置工程的依赖。POM包含以下几种信息： 项目版本 开发者信息 项目依赖 插件 执行目标 具体标签含义123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;!--父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。 坐标包括group ID，artifact ID和 version。 --&gt; &lt;parent&gt; &lt;!--被继承的父项目的构件标识符 --&gt; &lt;artifactId /&gt; &lt;!--被继承的父项目的全球唯一标识符 --&gt; &lt;groupId /&gt; &lt;!--被继承的父项目的版本 --&gt; &lt;version /&gt; &lt;!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。Maven首先在构建当前项目的地方寻找父项 目的pom，其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。 --&gt; &lt;relativePath /&gt; &lt;/parent&gt; &lt;!--声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!--项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， 如com.mycompany.app生成的相对路径为：/com/mycompany/app --&gt; &lt;groupId&gt;asia.banseon&lt;/groupId&gt; &lt;!-- 构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID和groupID；在某个 特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven为项目产生的构件包括：JARs，源 码，二进制发布和WARs等。 --&gt; &lt;artifactId&gt;banseon-maven2&lt;/artifactId&gt; &lt;!--项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型 --&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;!--项目当前版本，格式为:主版本.次版本.增量版本-限定版本号 --&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--项目的名称, Maven产生的文档用 --&gt; &lt;name&gt;banseon-maven&lt;/name&gt; &lt;!--项目主页的URL, Maven产生的文档用 --&gt; &lt;url&gt;http://www.baidu.com/banseon&lt;/url&gt; &lt;!-- 项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标 签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。 --&gt; &lt;description&gt;A maven project to study maven.&lt;/description&gt; &lt;!--描述了这个项目构建环境中的前提条件。 --&gt; &lt;prerequisites&gt; &lt;!--构建该项目或使用该插件所需要的Maven的最低版本 --&gt; &lt;maven /&gt; &lt;/prerequisites&gt; &lt;!--项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira --&gt; &lt;issueManagement&gt; &lt;!--问题管理系统（例如jira）的名字， --&gt; &lt;system&gt;jira&lt;/system&gt; &lt;!--该项目使用的问题管理系统的URL --&gt; &lt;url&gt;http://jira.baidu.com/banseon&lt;/url&gt; &lt;/issueManagement&gt; &lt;!--项目持续集成信息 --&gt; &lt;ciManagement&gt; &lt;!--持续集成系统的名字，例如continuum --&gt; &lt;system /&gt; &lt;!--该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。 --&gt; &lt;url /&gt; &lt;!--构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告） --&gt; &lt;notifiers&gt; &lt;!--配置一种方式，当构建中断时，以该方式通知用户/开发者 --&gt; &lt;notifier&gt; &lt;!--传送通知的途径 --&gt; &lt;type /&gt; &lt;!--发生错误时是否通知 --&gt; &lt;sendOnError /&gt; &lt;!--构建失败时是否通知 --&gt; &lt;sendOnFailure /&gt; &lt;!--构建成功时是否通知 --&gt; &lt;sendOnSuccess /&gt; &lt;!--发生警告时是否通知 --&gt; &lt;sendOnWarning /&gt; &lt;!--不赞成使用。通知发送到哪里 --&gt; &lt;address /&gt; &lt;!--扩展配置项 --&gt; &lt;configuration /&gt; &lt;/notifier&gt; &lt;/notifiers&gt; &lt;/ciManagement&gt; &lt;!--项目创建年份，4位数字。当产生版权信息时需要使用这个值。 --&gt; &lt;inceptionYear /&gt; &lt;!--项目相关邮件列表信息 --&gt; &lt;mailingLists&gt; &lt;!--该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。 --&gt; &lt;mailingList&gt; &lt;!--邮件的名称 --&gt; &lt;name&gt;Demo&lt;/name&gt; &lt;!--发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt; &lt;post&gt;banseon@126.com&lt;/post&gt; &lt;!--订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt; &lt;subscribe&gt;banseon@126.com&lt;/subscribe&gt; &lt;!--取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt; &lt;unsubscribe&gt;banseon@126.com&lt;/unsubscribe&gt; &lt;!--你可以浏览邮件信息的URL --&gt; &lt;archive&gt;http:/hi.baidu.com/banseon/demo/dev/&lt;/archive&gt; &lt;/mailingList&gt; &lt;/mailingLists&gt; &lt;!--项目开发者列表 --&gt; &lt;developers&gt; &lt;!--某个项目开发者的信息 --&gt; &lt;developer&gt; &lt;!--SCM里项目开发者的唯一标识符 --&gt; &lt;id&gt;HELLO WORLD&lt;/id&gt; &lt;!--项目开发者的全名 --&gt; &lt;name&gt;banseon&lt;/name&gt; &lt;!--项目开发者的email --&gt; &lt;email&gt;banseon@126.com&lt;/email&gt; &lt;!--项目开发者的主页的URL --&gt; &lt;url /&gt; &lt;!--项目开发者在项目中扮演的角色，角色元素描述了各种角色 --&gt; &lt;roles&gt; &lt;role&gt;Project Manager&lt;/role&gt; &lt;role&gt;Architect&lt;/role&gt; &lt;/roles&gt; &lt;!--项目开发者所属组织 --&gt; &lt;organization&gt;demo&lt;/organization&gt; &lt;!--项目开发者所属组织的URL --&gt; &lt;organizationUrl&gt;http://hi.baidu.com/banseon&lt;/organizationUrl&gt; &lt;!--项目开发者属性，如即时消息如何处理等 --&gt; &lt;properties&gt; &lt;dept&gt;No&lt;/dept&gt; &lt;/properties&gt; &lt;!--项目开发者所在时区， -11到12范围内的整数。 --&gt; &lt;timezone&gt;-5&lt;/timezone&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;!--项目的其他贡献者列表 --&gt; &lt;contributors&gt; &lt;!--项目的其他贡献者。参见developers/developer元素 --&gt; &lt;contributor&gt; &lt;name /&gt; &lt;email /&gt; &lt;url /&gt; &lt;organization /&gt; &lt;organizationUrl /&gt; &lt;roles /&gt; &lt;timezone /&gt; &lt;properties /&gt; &lt;/contributor&gt; &lt;/contributors&gt; &lt;!--该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。如果列出多个license，用户可以选择它们中的一个而不是接受所有license。 --&gt; &lt;licenses&gt; &lt;!--描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。 --&gt; &lt;license&gt; &lt;!--license用于法律上的名称 --&gt; &lt;name&gt;Apache 2&lt;/name&gt; &lt;!--官方的license正文页面的URL --&gt; &lt;url&gt;http://www.baidu.com/banseon/LICENSE-2.0.txt&lt;/url&gt; &lt;!--项目分发的主要方式： repo，可以从Maven库下载 manual， 用户必须手动下载和安装依赖 --&gt; &lt;distribution&gt;repo&lt;/distribution&gt; &lt;!--关于license的补充信息 --&gt; &lt;comments&gt;A business-friendly OSS license&lt;/comments&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;!--SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。 --&gt; &lt;scm&gt; &lt;!--SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。 --&gt; &lt;connection&gt; scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk) &lt;/connection&gt; &lt;!--给开发者使用的，类似connection元素。即该连接不仅仅只读 --&gt; &lt;developerConnection&gt; scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk &lt;/developerConnection&gt; &lt;!--当前代码的标签，在开发阶段默认为HEAD --&gt; &lt;tag /&gt; &lt;!--指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。 --&gt; &lt;url&gt;http://svn.baidu.com/banseon&lt;/url&gt; &lt;/scm&gt; &lt;!--描述项目所属组织的各种属性。Maven产生的文档用 --&gt; &lt;organization&gt; &lt;!--组织的全名 --&gt; &lt;name&gt;demo&lt;/name&gt; &lt;!--组织主页的URL --&gt; &lt;url&gt;http://www.baidu.com/banseon&lt;/url&gt; &lt;/organization&gt; &lt;!--构建项目需要的信息 --&gt; &lt;build&gt; &lt;!--该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt; &lt;sourceDirectory /&gt; &lt;!--该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。 --&gt; &lt;scriptSourceDirectory /&gt; &lt;!--该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt; &lt;testSourceDirectory /&gt; &lt;!--被编译过的应用程序class文件存放的目录。 --&gt; &lt;outputDirectory /&gt; &lt;!--被编译过的测试class文件存放的目录。 --&gt; &lt;testOutputDirectory /&gt; &lt;!--使用来自该项目的一系列构建扩展 --&gt; &lt;extensions&gt; &lt;!--描述使用到的构建扩展。 --&gt; &lt;extension&gt; &lt;!--构建扩展的groupId --&gt; &lt;groupId /&gt; &lt;!--构建扩展的artifactId --&gt; &lt;artifactId /&gt; &lt;!--构建扩展的版本 --&gt; &lt;version /&gt; &lt;/extension&gt; &lt;/extensions&gt; &lt;!--当项目没有规定目标（Maven2 叫做阶段）时的默认值 --&gt; &lt;defaultGoal /&gt; &lt;!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。 --&gt; &lt;resources&gt; &lt;!--这个元素描述了项目相关或测试相关的所有资源路径 --&gt; &lt;resource&gt; &lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如$&#123;project.build.outputDirectory&#125;）。举个例 子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven /messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --&gt; &lt;targetPath /&gt; &lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。 --&gt; &lt;filtering /&gt; &lt;!--描述存放资源的目录，该路径相对POM路径 --&gt; &lt;directory /&gt; &lt;!--包含的模式列表，例如**/*.xml. --&gt; &lt;includes /&gt; &lt;!--排除的模式列表，例如**/*.xml --&gt; &lt;excludes /&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;!--这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。 --&gt; &lt;testResources&gt; &lt;!--这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明 --&gt; &lt;testResource&gt; &lt;targetPath /&gt; &lt;filtering /&gt; &lt;directory /&gt; &lt;includes /&gt; &lt;excludes /&gt; &lt;/testResource&gt; &lt;/testResources&gt; &lt;!--构建产生的所有文件存放的目录 --&gt; &lt;directory /&gt; &lt;!--产生的构件的文件名，默认值是$&#123;artifactId&#125;-$&#123;version&#125;。 --&gt; &lt;finalName /&gt; &lt;!--当filtering开关打开时，使用到的过滤器属性文件列表 --&gt; &lt;filters /&gt; &lt;!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置 --&gt; &lt;pluginManagement&gt; &lt;!--使用的插件列表 。 --&gt; &lt;plugins&gt; &lt;!--plugin元素包含描述插件所需要的信息。 --&gt; &lt;plugin&gt; &lt;!--插件在仓库里的group ID --&gt; &lt;groupId /&gt; &lt;!--插件在仓库里的artifact ID --&gt; &lt;artifactId /&gt; &lt;!--被使用的插件的版本（或版本范围） --&gt; &lt;version /&gt; &lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。 --&gt; &lt;extensions /&gt; &lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --&gt; &lt;executions&gt; &lt;!--execution元素包含了插件执行需要的信息 --&gt; &lt;execution&gt; &lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --&gt; &lt;id /&gt; &lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --&gt; &lt;phase /&gt; &lt;!--配置的执行目标 --&gt; &lt;goals /&gt; &lt;!--配置是否被传播到子POM --&gt; &lt;inherited /&gt; &lt;!--作为DOM对象的配置 --&gt; &lt;configuration /&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;!--项目引入插件所需要的额外依赖 --&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素 --&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--任何配置是否被传播到子项目 --&gt; &lt;inherited /&gt; &lt;!--作为DOM对象的配置 --&gt; &lt;configuration /&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;!--使用的插件列表 --&gt; &lt;plugins&gt; &lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt; &lt;plugin&gt; &lt;groupId /&gt; &lt;artifactId /&gt; &lt;version /&gt; &lt;extensions /&gt; &lt;executions&gt; &lt;execution&gt; &lt;id /&gt; &lt;phase /&gt; &lt;goals /&gt; &lt;inherited /&gt; &lt;configuration /&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素 --&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;goals /&gt; &lt;inherited /&gt; &lt;configuration /&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!--在列的项目构建profile，如果被激活，会修改构建处理 --&gt; &lt;profiles&gt; &lt;!--根据环境参数或命令行参数激活某个构建处理 --&gt; &lt;profile&gt; &lt;!--构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。 --&gt; &lt;id /&gt; &lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它 能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。 --&gt; &lt;activation&gt; &lt;!--profile默认是否激活的标志 --&gt; &lt;activeByDefault /&gt; &lt;!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。 --&gt; &lt;jdk /&gt; &lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --&gt; &lt;os&gt; &lt;!--激活profile的操作系统的名字 --&gt; &lt;name&gt;Windows XP&lt;/name&gt; &lt;!--激活profile的操作系统所属家族(如 'windows') --&gt; &lt;family&gt;Windows&lt;/family&gt; &lt;!--激活profile的操作系统体系结构 --&gt; &lt;arch&gt;x86&lt;/arch&gt; &lt;!--激活profile的操作系统版本 --&gt; &lt;version&gt;5.1.2600&lt;/version&gt; &lt;/os&gt; &lt;!--如果Maven检测到某一个属性（其值可以在POM中通过$&#123;名称&#125;引用），其拥有对应的名称和值，Profile就会被激活。如果值 字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --&gt; &lt;property&gt; &lt;!--激活profile的属性的名称 --&gt; &lt;name&gt;mavenVersion&lt;/name&gt; &lt;!--激活profile的属性的值 --&gt; &lt;value&gt;2.0.3&lt;/value&gt; &lt;/property&gt; &lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活 profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --&gt; &lt;file&gt; &lt;!--如果指定的文件存在，则激活profile。 --&gt; &lt;exists&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/ &lt;/exists&gt; &lt;!--如果指定的文件不存在，则激活profile。 --&gt; &lt;missing&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/ &lt;/missing&gt; &lt;/file&gt; &lt;/activation&gt; &lt;!--构建项目所需要的信息。参见build元素 --&gt; &lt;build&gt; &lt;defaultGoal /&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath /&gt; &lt;filtering /&gt; &lt;directory /&gt; &lt;includes /&gt; &lt;excludes /&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;testResources&gt; &lt;testResource&gt; &lt;targetPath /&gt; &lt;filtering /&gt; &lt;directory /&gt; &lt;includes /&gt; &lt;excludes /&gt; &lt;/testResource&gt; &lt;/testResources&gt; &lt;directory /&gt; &lt;finalName /&gt; &lt;filters /&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt; &lt;plugin&gt; &lt;groupId /&gt; &lt;artifactId /&gt; &lt;version /&gt; &lt;extensions /&gt; &lt;executions&gt; &lt;execution&gt; &lt;id /&gt; &lt;phase /&gt; &lt;goals /&gt; &lt;inherited /&gt; &lt;configuration /&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素 --&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;goals /&gt; &lt;inherited /&gt; &lt;configuration /&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;plugins&gt; &lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt; &lt;plugin&gt; &lt;groupId /&gt; &lt;artifactId /&gt; &lt;version /&gt; &lt;extensions /&gt; &lt;executions&gt; &lt;execution&gt; &lt;id /&gt; &lt;phase /&gt; &lt;goals /&gt; &lt;inherited /&gt; &lt;configuration /&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素 --&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;goals /&gt; &lt;inherited /&gt; &lt;configuration /&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt; &lt;modules /&gt; &lt;!--发现依赖和扩展的远程仓库列表。 --&gt; &lt;repositories&gt; &lt;!--参见repositories/repository元素 --&gt; &lt;repository&gt; &lt;releases&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/snapshots&gt; &lt;id /&gt; &lt;name /&gt; &lt;url /&gt; &lt;layout /&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --&gt; &lt;pluginRepositories&gt; &lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt; &lt;pluginRepository&gt; &lt;releases&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/snapshots&gt; &lt;id /&gt; &lt;name /&gt; &lt;url /&gt; &lt;layout /&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素 --&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--不赞成使用. 现在Maven忽略该元素. --&gt; &lt;reports /&gt; &lt;!--该元素包括使用报表插件产生报表的规范。当用户执行"mvn site"，这些报表就会运行。 在页面导航栏能看到所有报表的链接。参见reporting元素 --&gt; &lt;reporting&gt; ...... &lt;/reporting&gt; &lt;!--参见dependencyManagement元素 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素 --&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!--参见distributionManagement元素 --&gt; &lt;distributionManagement&gt; ...... &lt;/distributionManagement&gt; &lt;!--参见properties元素 --&gt; &lt;properties /&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt; &lt;modules /&gt; &lt;!--发现依赖和扩展的远程仓库列表。 --&gt; &lt;repositories&gt; &lt;!--包含需要连接到远程仓库的信息 --&gt; &lt;repository&gt; &lt;!--如何处理远程仓库里发布版本的下载 --&gt; &lt;releases&gt; &lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt; &lt;enabled /&gt; &lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt; &lt;updatePolicy /&gt; &lt;!--当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。 --&gt; &lt;checksumPolicy /&gt; &lt;/releases&gt; &lt;!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的 策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt; &lt;snapshots&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/snapshots&gt; &lt;!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 --&gt; &lt;id&gt;banseon-repository-proxy&lt;/id&gt; &lt;!--远程仓库名称 --&gt; &lt;name&gt;banseon-repository-proxy&lt;/name&gt; &lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt; &lt;url&gt;http://192.168.1.169:9999/repository/&lt;/url&gt; &lt;!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然 而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --&gt; &lt;pluginRepositories&gt; &lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt; &lt;pluginRepository&gt; ...... &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;!--依赖的group ID --&gt; &lt;groupId&gt;org.apache.maven&lt;/groupId&gt; &lt;!--依赖的artifact ID --&gt; &lt;artifactId&gt;maven-artifact&lt;/artifactId&gt; &lt;!--依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。 --&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应， 尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在 plugin里定义新的类型。所以前面的类型的例子不完整。 --&gt; &lt;type&gt;jar&lt;/type&gt; &lt;!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，如果你想要构建两个单独的构件成 JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生成两个单独的JAR构件。 --&gt; &lt;classifier&gt;&lt;/classifier&gt; &lt;!--依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 - compile ：默认范围，用于编译 - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath - runtime: 在执行时需要使用 - test: 用于test任务时使用 - system: 需要外在提供相应的元素。通过systemPath来取得 - systemPath: 仅用于范围为system。提供相应的路径 - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;!--仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如$&#123;java.home&#125;。 --&gt; &lt;systemPath&gt;&lt;/systemPath&gt; &lt;!--当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;!--可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。 --&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--不赞成使用. 现在Maven忽略该元素. --&gt; &lt;reports&gt;&lt;/reports&gt; &lt;!--该元素描述使用报表插件产生报表的规范。当用户执行"mvn site"，这些报表就会运行。 在页面导航栏能看到所有报表的链接。 --&gt; &lt;reporting&gt; &lt;!--true，则，网站不包括默认的报表。这包括"项目信息"菜单中的报表。 --&gt; &lt;excludeDefaults /&gt; &lt;!--所有产生的报表存放到哪里。默认值是$&#123;project.build.directory&#125;/site。 --&gt; &lt;outputDirectory /&gt; &lt;!--使用的报表插件和他们的配置。 --&gt; &lt;plugins&gt; &lt;!--plugin元素包含描述报表插件需要的信息 --&gt; &lt;plugin&gt; &lt;!--报表插件在仓库里的group ID --&gt; &lt;groupId /&gt; &lt;!--报表插件在仓库里的artifact ID --&gt; &lt;artifactId /&gt; &lt;!--被使用的报表插件的版本（或版本范围） --&gt; &lt;version /&gt; &lt;!--任何配置是否被传播到子项目 --&gt; &lt;inherited /&gt; &lt;!--报表插件的配置 --&gt; &lt;configuration /&gt; &lt;!--一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标 --&gt; &lt;reportSets&gt; &lt;!--表示报表的一个集合，以及产生该集合的配置 --&gt; &lt;reportSet&gt; &lt;!--报表集合的唯一标识符，POM继承时用到 --&gt; &lt;id /&gt; &lt;!--产生报表集合时，被使用的报表的配置 --&gt; &lt;configuration /&gt; &lt;!--配置是否被继承到子POMs --&gt; &lt;inherited /&gt; &lt;!--这个集合里使用到哪些报表 --&gt; &lt;reports /&gt; &lt;/reportSet&gt; &lt;/reportSets&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/reporting&gt; &lt;!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和 artifact ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID 匹配到这里的依赖，并使用这里的依赖信息。 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素 --&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!--项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。 --&gt; &lt;distributionManagement&gt; &lt;!--部署项目产生的构件到远程仓库需要的信息 --&gt; &lt;repository&gt; &lt;!--是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见repositories/repository元素 --&gt; &lt;uniqueVersion /&gt; &lt;id&gt;banseon-maven2&lt;/id&gt; &lt;name&gt;banseon maven2&lt;/name&gt; &lt;url&gt;file://$&#123;basedir&#125;/target/deploy&lt;/url&gt; &lt;layout /&gt; &lt;/repository&gt; &lt;!--构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见distributionManagement/repository元素 --&gt; &lt;snapshotRepository&gt; &lt;uniqueVersion /&gt; &lt;id&gt;banseon-maven2&lt;/id&gt; &lt;name&gt;Banseon-maven2 Snapshot Repository&lt;/name&gt; &lt;url&gt;scp://svn.baidu.com/banseon:/usr/local/maven-snapshot&lt;/url&gt; &lt;layout /&gt; &lt;/snapshotRepository&gt; &lt;!--部署项目的网站需要的信息 --&gt; &lt;site&gt; &lt;!--部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置 --&gt; &lt;id&gt;banseon-site&lt;/id&gt; &lt;!--部署位置的名称 --&gt; &lt;name&gt;business api website&lt;/name&gt; &lt;!--部署位置的URL，按protocol://hostname/path形式 --&gt; &lt;url&gt; scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web &lt;/url&gt; &lt;/site&gt; &lt;!--项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。 --&gt; &lt;downloadUrl /&gt; &lt;!--如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。 --&gt; &lt;relocation&gt; &lt;!--构件新的group ID --&gt; &lt;groupId /&gt; &lt;!--构件新的artifact ID --&gt; &lt;artifactId /&gt; &lt;!--构件新的版本号 --&gt; &lt;version /&gt; &lt;!--显示给用户的，关于移动的额外信息，例如原因。 --&gt; &lt;message /&gt; &lt;/relocation&gt; &lt;!-- 给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值有：none（默认），converted（仓库管理员从 Maven 1 POM转换过来），partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部 署），verified（被核实时正确的和最终的）。 --&gt; &lt;status /&gt; &lt;/distributionManagement&gt; &lt;!--以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里activation元素的说明）。格式是&lt;name&gt;value&lt;/name&gt;。 --&gt; &lt;properties /&gt;&lt;/project&gt;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux中top命令结果详解]]></title>
    <url>%2F2020%2F03%2F28%2FLinux%E4%B8%ADtop%E5%91%BD%E4%BB%A4%E7%BB%93%E6%9E%9C%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[top命令作为监控系统运行最常用的命令。初次去看它的面板是很迷惑的，甚至看过很多次的解析也没能记得住，所以在这里进行总结归纳，再让自己记一遍。 命令作用top命令提供了实时的对系统处理器的状态监视.它将显示系统中CPU最“敏感”的任务列表.该命令可以按CPU使用.内存使用和执行时间对任务进行排序；而且该命令的很多特性都可以通过交互式命令或者在个人定制文件中进行设定。实时数据如下图显示： 我们看到整个界面分为两个部分，上半部分主要显示总的系统资源使用情况。下半部分显示了进程的资源使用情况。 上半部分第一行 字符 含义 top - 14:25:03 当前系统时间 up 5:03 系统已运行时间 1 user 在线用户数 loadaverage: 0.97,0.43,0.26 系统负载。分别是1分钟，5分钟，15分钟的平均值 第二行 字符 含义 任务：374 total 总进程数 1 running 正在运行的进程数 300 sleeping 睡眠状态的进程数 0 stopped 停止的进程数 1 zombie 僵尸进程数 第三行第三行主要显示CPU的占用率 字符 含义 %Cpu(s): 4.4us 用户进程的CPU占用率 1.6 sy 系统CPU占用率 0.0 ni 用户进程空间内改变过优先级的进程占用CPU百分比 93.9 id CPU空闲率 0.0 wa 等待IO的CPU时间百分比 0.0 hi 硬中断占用CPU的百分比 0.1 si 软中断占用CPU的百分比 0.0 st 虚拟机占用CPU的百分比 第四行第四行主要显示内存的占用率。KiB Mem 表示以KB为单位 字符 含义 16142048 total 物理内存总量 3908996 free 空闲的内存总量 5087380 used 使用的物理内存总量 7145672 buff/cache 用作内存缓存的内存量 第五行第五行主要显示了交换区的占用率。KiB Swap 表示以KB为单位字符 | 含义 | -2097148 tatal | 交换区总量2097148 free | 空闲的交换区总量0 used | 使用的交换区总量9832576 avail Mem | 可用内存空间 下半部分这里主要显示的是进程的资源占用情况。 字符 含义 PID 进程号 USER 进程的创建用户 PR 进程优先级 NI nice值，越小优先级越高。最小-20。最大20 VIRT 使用的虚拟内存总量。单位KB VIRT=SWAP+RES RES 进程使用的，未被换出的物理内存大小，单位KB。RES=CODE+DATA SHR 共享内存大小，单位KB S 进程状态。R=运行，S=可中断睡眠，D=不可中断睡眠，Z=僵尸状态 %CPU 进程占用CPU百分比 %MEM 进程占用内存百分比 TIME+ 进程已运行时间 COMMAND 进程的名称]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式——模板方法模式]]></title>
    <url>%2F2020%2F03%2F28%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[模板方法模式，顾名思义就是使用一个模板去约束子类的实现过程，抽出分类一个过程的公共部分，再由子类去实现每个过程不同的具体实现。将重复的代码固定下来，共有的流程抽象出来，封装成模板，就是我们要讲的模板方法模式。 模板方法模式，定义一个操作中的算法的骨架，而将一些步骤，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 类图就不画了，很简单。直接上代码，看起来很简单。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455abstract class WriteArticle&#123; abstract void writeIntroduction(); abstract void writeContent(); abstract void writeLast(); public final void writeAnArticle()&#123; writeIntroduction(); writeContent(); writeLast(); &#125;&#125;class AWriteArticle extends WriteArticle&#123; @Override void writeIntroduction() &#123; System.out.println("张三写前言"); &#125; @Override void writeContent() &#123; System.out.println("张三写正文"); &#125; @Override void writeLast() &#123; System.out.println("张三写结语"); &#125;&#125;class BWriteArticle extends WriteArticle&#123; @Override void writeIntroduction() &#123; System.out.println("李四写前言"); &#125; @Override void writeContent() &#123; System.out.println("李四写正文"); &#125; @Override void writeLast() &#123; System.out.println("李四写结语"); &#125;&#125;public class TemplateMethod &#123; public static void main(String[] args)&#123; WriteArticle zhangsan = new AWriteArticle(); zhangsan.writeAnArticle(); WriteArticle lisi = new BWriteArticle(); lisi.writeAnArticle(); &#125;&#125; 核心思想是模板方法模式通过把不变形为搬到超类中，去除子类中重复代码体现它的优势。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式——责任链模式]]></title>
    <url>%2F2020%2F03%2F19%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[如果我们的业务场景需要对一个对象进行不同的操作，像一条流水线一样各自改变这个对象的某一属性，为了减少这些操作的耦合度，即解除发送者和接受者之间的耦合关系，可以使用责任链模式，将这些处理划分成这个处理流水线上的一个个节点，进而明确责任，当这些操作需要修改的时候，使用责任链易于维护和重构。 职责连模式(Chain of Responsibility): 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这个链条传递该请求，直到有一个对象处理它为止。 由于在项目中直接使用到了，所以这里记录直接使用Spring的特性对传统的职责链进行改造的方法。 在责任链模式中有三个角色 抽象父类，Handler。这里定义所有子类公用的资源，抽象的执行方法。以及每个子类的下一个节点。 具体处理者，定义具体的处理方法。 配置类，对链条进行管理，并向外提供链条的使用接口。 具体代码如下： 抽象类 Handler 1234567891011121314151617181920public abstract class Handler &#123; private Handler next; public Handler getNext() &#123; return next; &#125; public void setNext(Handler next) &#123; this.next = next; &#125; public void execute()&#123; System.out.println(getResult()); if(next != null)&#123; getNext().execute(); &#125; &#125; public abstract String getResult();&#125; 执行者1 123456789@Order(1)@Componentpublic class One extends Handler&#123; @Override public String getResult() &#123; return "One"; &#125;&#125; 执行者2 12345678@Order(2)@Componentpublic class Two extends Handler &#123; @Override public String getResult() &#123; return "Two"; &#125;&#125; 配置类 12345678910111213141516171819202122@Configurationpublic class InitHandler &#123; @Autowired List&lt;Handler&gt; handlerList; @PostConstruct private void initHandler() &#123; Collections.sort(handlerList, AnnotationAwareOrderComparator.INSTANCE); int size = handlerList.size(); for (int i = 0; i &lt; size; i++) &#123; if(i == size-1)&#123; handlerList.get(i).setNext(null); &#125;else&#123; handlerList.get(i).setNext(handlerList.get(i+1)); &#125; &#125; &#125; public void run(Integer i)&#123; handlerList.get(i).execute(); &#125;&#125; @Order 注解在Spring初始化时对素有类进行排序。配置类利用了Spring的特性对所有类进行初始化和管理。比传统的new更优雅一点。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式——代理模式]]></title>
    <url>%2F2020%2F01%2F12%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[代理模式，顾名思义就是造一个中间商，什么情况下会需要一个中间商呢？比如我们提供服务的对象不在本地，那么我们可以造一个本地的代理，用来代替远程的服务。不管远程的服务怎么改变，我们只需要变代理就可以，具体的业务逻辑不需要改变。再比如我提供的服务需要控制权限，那么可以使用一个代理，这个代理拥有对象的一部分使用权限，另一部分是无法使用的。 代理模式(Proxy)，为其他对象提供一种代理以控制对这个对象的访问。 代理模式的类图可以如下表示： Subject 抽象主题角色：可以是抽象类，也可以是接口。抽象主题是一个普通的业务类型，无特殊要求。 RealSubject 具体主题角色：也叫做被委托角色或被代理角色，是业务逻辑的具体执行者。 Proxy 代理主题角色：也叫做委托类或代理类。它负责对真实角色的应用，把所有抽象主题类定义的方法限制委托给真实主题角色实现，并且在具体主题角色处理完毕前后做预处理和善后处理工作。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041package Proxy;interface IRenting&#123; /** * 租房 * @return 租金 */ Integer rent();&#125;/** * 房东 */class HouseOwner implements IRenting&#123; @Override public Integer rent()&#123; System.out.println("房东租房，租金100"); return 100; &#125;&#125;/** * 中介 */class Proxy implements IRenting&#123; @Override public Integer rent()&#123; HouseOwner houseOwner = new HouseOwner(); Integer rent = houseOwner.rent(); System.out.println("中介租房，盈利一百"); return rent+100; &#125;&#125;public class ProxyPattern &#123; public static void main(String[] args)&#123; Proxy proxy = new Proxy(); Integer rent = proxy.rent(); System.out.println("房客租金："+rent+",房客和房东无关，并不知道房东的存在"); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式——装饰模式]]></title>
    <url>%2F2019%2F12%2F08%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[装饰模式装饰模式并不影响对象的核心属性，而是作为装饰者赋予他的其他属性，比如人穿衣服，脱了衣服人还是人，和建造者模式相比，装饰者模式具有不确定性，作为建造者来说，建造的对象一定时固定的。这就是建造者和装饰者的区别，那么作为装饰赋予对象其他的职责为什么不使用继承呢？装饰者相比于继承的好处是免去了继承把装饰过程暴露给了客户端，并且装饰模式更加的灵活。 装饰模式(Decorator)，动态的给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更加灵活。 下面时装饰者模式的类图。 Component定义一个接口，可以给对象动态的添加职责。 ConcreteComponet是定义的具体对象。 Decorator是装饰抽象类，继承了Component，从外类扩展Component的功能，对于Component来说，并不需要知道Decorator的存在。 ConcreteDecorator是具体的装饰对象，给Component添加职责。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576interface Shape &#123; void draw();&#125;class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println("Shape:Circle"); &#125;&#125;class Rectangle implements Shape &#123; @Override public void draw() &#123; System.out.println("Shape:Rectangle"); &#125;&#125;abstract class ShapeDecorator implements Shape &#123; protected Shape decoratedShape; public ShapeDecorator(Shape decoratedShape) &#123; this.decoratedShape = decoratedShape; &#125; public void draw() &#123; decoratedShape.draw(); &#125;&#125;class RedShapeDecorator extends ShapeDecorator &#123; public RedShapeDecorator(Shape decoratedShape) &#123; super(decoratedShape); &#125; @Override public void draw() &#123; decoratedShape.draw(); setRedBorder(decoratedShape); &#125; private void setRedBorder(Shape decoratedShape) &#123; System.out.println("Border Color: Red"); &#125;&#125;class GreenShapeDecorator extends ShapeDecorator&#123; public GreenShapeDecorator(Shape decoratedShape) &#123; super(decoratedShape); &#125; @Override public void draw() &#123; decoratedShape.draw(); setGreenBorder(decoratedShape); &#125; private void setGreenBorder(Shape decoratedShape) &#123; System.out.println("Border Color: Green"); &#125;&#125;public class DecoratorPattern &#123; public static void main(String args[]) &#123; Shape circle = new Circle(); Shape Rectangle = new Rectangle(); ShapeDecorator redCicle = new RedShapeDecorator(circle); ShapeDecorator redRectangle = new RedShapeDecorator(Rectangle); ShapeDecorator greenCicle = new GreenShapeDecorator(circle); ShapeDecorator greenRectangle = new GreenShapeDecorator(redRectangle); redCicle.draw(); redRectangle.draw(); greenCicle.draw(); greenRectangle.draw(); &#125;&#125; 常用情况下，ConcreteComponnet只有一个类，不需用抽象的时候，Decorator作为Component的一个子类就可以了。相当于装饰类继承自具体的对象，然后再进行泛化成各种各样的装饰类。那么此时就相当于装饰类继承了原始类，但是这个装饰类是一个抽象类，可以通过抽象类的灵活性对原始类进行装饰活动。]]></content>
  </entry>
  <entry>
    <title><![CDATA[设计模式——策略模式]]></title>
    <url>%2F2019%2F12%2F02%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[策略模式将算法作为一种策略传入对象，做到了算法和数据的分离，算法可以根据具体的需求进行无缝替换，和简单工厂模式实现的效果时一样的，但是实现的思想不同。 策略模式（Strategy）：它定义了算法家族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。 策略模式有如下的角色： Context上下文：属于配置类，通过这个类来控制具体使用哪一种策略。是高层使用者和底层策略之间的接口，封装了具体策略的内容。 Strategy类：抽象策略类，是对所有算法的抽象，抽象类和接口都可。 具体的策略类：在这些类中实现了具体的算法。 策略模式的UML类图如下： 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package StrategyPattern;abstract class Operation&#123; public abstract &lt;T extends Number&gt; double getResult(T paramA, T paramB);&#125;class Add extends Operation&#123; @Override public &lt;T extends Number&gt; double getResult(T paramA, T paramB)&#123; return paramA.doubleValue() + paramB.doubleValue(); &#125;&#125;class Sub extends Operation&#123; @Override public &lt;T extends Number&gt; double getResult(T paramA, T paramB)&#123; return paramA.doubleValue() - paramB.doubleValue(); &#125;&#125;class Mul extends Operation&#123; @Override public &lt;T extends Number&gt; double getResult(T paramA, T paramB)&#123; return paramA.doubleValue() * paramB.doubleValue(); &#125;&#125;class Div extends Operation&#123; @Override public &lt;T extends Number&gt; double getResult(T paramA, T paramB)&#123; return paramA.doubleValue() / paramB.doubleValue(); &#125;&#125;class Context&#123; private Operation operation; public Context()&#123; &#125; public void setStrategy(Operation operation)&#123; this.operation = operation; &#125; public &lt;T extends Number&gt; double executeStrategy(T paramA, T paramB)&#123; return operation.getResult(paramA, paramB); &#125;&#125;public class StrategyPattern &#123; public static void main(String args[])&#123; Context context = new Context(); context.setStrategy(new Add()); System.out.println("10+10="+context.executeStrategy(10,10)); context.setStrategy(new Sub()); System.out.println("11.5-10.2="+context.executeStrategy(11.5,10.2)); context.setStrategy(new Mul()); System.out.println("10*11="+context.executeStrategy(10L,11L)); context.setStrategy(new Div()); System.out.println("14/2="+context.executeStrategy(14,2)); &#125;&#125; 什么时候用策略模式呢？在上面的代码中我们看到加减乘除作为了一种策略传递给了策略上下文来进行配置。避免了大量的if-else和switch的出现。是一种常用的设计模式。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式——建造者模式，原型模式，单例模式]]></title>
    <url>%2F2019%2F11%2F23%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[本节总结的三个模式，是工厂模式后剩余的三个创建型模式，都是生产对象的模板代码，各有特色。 建造者模式建造者模式的思想是将一个复杂的对象的构建与他的表示分离，使得同样的构建过程可以表示创建不同的表示。工厂模式主要是生产相对简单的对象，它控制了一个个的流水线，产品通过这些预设的流水线来生产产品。而建造者模式更像是控制生产线上的一个个工人，负责决定生产什么样的产品，每一个工人负责一个模块，将实现和构建分离，根据不同的产品去替换生产线上的某个工人。最后可以实现复用一条生产线生产不同的产品。建造者模式的角色如下： Builder 抽象的建造者，不是必须的 ConcreateBuilder 具体的建造者 可以有多个「因为每个建造风格可能不一样」 Product 具体的产品「即被建造的对象」 Director 指挥者 统一指挥建造者去建造目标，导演不是必须的 建造者模式的UML类图如下：代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141/** * 抽象建造者 */abstract class Builder&#123; /** * 建造地基 */ abstract void buildGround(); /** * 砌墙 */ abstract void buildWall(); /** * 盖房顶 */ abstract void buildRoof(); /** * 得到最终的房子 */ abstract Product getRoom();&#125;/** * 产品 */class Product&#123; /** * 地面 */ private String ground; /** * 墙 */ private String wall; /** * 屋顶 */ private String roof; public String getGround() &#123; return ground; &#125; public void setGround(String ground) &#123; this.ground = ground; &#125; public String getWall() &#123; return wall; &#125; public void setWall(String wall) &#123; this.wall = wall; &#125; public String getRoof() &#123; return roof; &#125; public void setRoof(String roof) &#123; this.roof = roof; &#125; @Override public String toString()&#123; return "建造了"+ground+' '+wall+' '+roof+"的房子"; &#125;&#125;/** * 具体建造者 */class ConcreteBuilder extends Builder&#123; private Product product; public ConcreteBuilder()&#123; product = new Product(); &#125; @Override void buildGround()&#123; product.setGround("白色的地面"); &#125; @Override void buildWall()&#123; product.setWall("黄色的墙面"); &#125; @Override void buildRoof()&#123; product.setRoof("红色的屋顶"); &#125; @Override Product getRoom()&#123; return product; &#125;&#125;/** * 另一个具体的建造者 */class AnotherBuilder extends Builder&#123; private Product product; public AnotherBuilder()&#123; product = new Product(); &#125; @Override void buildGround()&#123; product.setGround("黑色的地面"); &#125; @Override void buildWall()&#123; product.setWall("绿色的墙面"); &#125; @Override void buildRoof()&#123; product.setRoof("白色的屋顶"); &#125; @Override Product getRoom()&#123; return product; &#125;&#125;/** * 指挥者，控制建造的过程 */class Director&#123; public Product create(Builder builder)&#123; builder.buildGround(); builder.buildRoof(); builder.buildWall(); return builder.getRoom(); &#125;&#125;public class BuilderPattern &#123; public static void main(String[] args)&#123; Director director = new Director(); Product roomA = director.create(new ConcreteBuilder()); System.out.println(roomA.toString()); Product roomB = director.create(new AnotherBuilder()); System.out.println(roomB.toString()); &#125;&#125; 原型模式当创建的对象有很多共用的属性时就可以使用原型模式，原型模式就好比孙悟空一根毫毛变出无数个小猴子，通过对象的复制免去了新建对象需要执行构造器的步骤，通过clone就可以得到一个新的对象。 原型模式的角色如下： 抽象原型类：声明克隆方法的接口，是所有原型类的公共父类，可以使接口，抽象类或者直接时一个具体的实现类。 具体原型类：实现了抽象原型类中声明的克隆方法，在克隆方法中返回自己的克隆对象。 客户类，客户类中通过对象实现的克隆方法创建对象，并根据客户端的具体要求个性化对象的属性。 原型模式的UML类图如下： 简单代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import java.io.*;/** * 具体原型类，Object类已经实现了clone接口 */class Room implements Serializable &#123; private String roof; private String wall; private String ground; public String getRoof() &#123; return roof; &#125; public void setRoof(String roof) &#123; this.roof = roof; &#125; public String getWall() &#123; return wall; &#125; public void setWall(String wall) &#123; this.wall = wall; &#125; public String getGround() &#123; return ground; &#125; public void setGround(String ground) &#123; this.ground = ground; &#125; @Override public String toString()&#123; return "建造了"+ground+' '+wall+' '+roof+"的房子@"+hashCode(); &#125; public Room clone() &#123; try &#123; ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); ObjectOutputStream outObject = new ObjectOutputStream(outputStream); outObject.writeObject(this); ByteArrayInputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray()); ObjectInputStream inObject = new ObjectInputStream(inputStream); return (Room) inObject.readObject(); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125;public class PrototypePattern &#123; public static void main(String[] args)&#123; Room room1 = new Room(); room1.setGround("白色地面"); room1.setRoof("白色的屋顶"); room1.setWall("红色的墙壁"); Room room2 = room1.clone(); room2.setWall("绿色的墙壁"); System.out.println(room1); System.out.println(room2); &#125;&#125; 单例模式单例模式算是最简单的一个设计模式了，如果一个类在系统运行过程中只需要一个对象的时候就可以使用单例模式了，单例模式在编码过程中有大量了应用。比如配置类对象，日志类对象，这些对象非常常用但是又毫无变化，那么就直接在系统中创建一个对象就行了，每次需要的时候也不用重新创建，拿来就用。 在java中单例模式是非常容易创建的，最简单的方式就是让构造器私有，并且只在内部实例化，给外部提供一个方法，每次通过这个方法就可以拿到这个对象，非常简单，类图就不画了，直接上代码，一看就懂。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Room&#123; /** * 私有构造函数，屏蔽掉默认的公有构造函数 */ private Room()&#123; &#125; private static Room instance = new Room(); private String ground; private String wall; private String roof; public String getGround() &#123; return ground; &#125; public void setGround(String ground) &#123; this.ground = ground; &#125; public String getWall() &#123; return wall; &#125; public void setWall(String wall) &#123; this.wall = wall; &#125; public String getRoof() &#123; return roof; &#125; public void setRoof(String roof) &#123; this.roof = roof; &#125; @Override public String toString()&#123; return "建造了"+ground+' '+wall+' '+roof+"的房子@"+hashCode(); &#125; public static Room getInstance()&#123; return instance; &#125;&#125;public class SinglePattern &#123; public static void main(String[] args)&#123; Room room = Room.getInstance(); room.setGround("绿色的地板"); room.setRoof("白色的屋顶"); room.setWall("白色的墙"); System.out.println(room); Room room2 = Room.getInstance(); room2.setWall("绿色的墙"); System.out.println(room2); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式——工厂模式]]></title>
    <url>%2F2019%2F11%2F21%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[不要过度设计，学习设计模式之前一定要牢记的一句话。过度设计并不是学习设计模式的初衷。我们使用设计模式就是为了能写出易维护，易扩展，易复用，灵活多样的应用，在合适的情况下使用合适的设计模式，才能达到理想的效果。23种设计模式只是模板代码，只有理解其中的思想，才能无招胜有招。现在我们先学习这些招式。从三工厂开始。 工厂模式，顾名思义，这就是个工厂，用来生产对象，直接在调用方New对象是不是耦合严重了呢？一但类名发生了变化，就要重新改代码了吗？工厂模式，解决了这个问题，通过第三方工厂去生产对象，符合依赖倒转原则。 简单工厂模式先说说什么叫简单工厂（Simple Factory），这就太简单了，如果你不想直接在调用方new一些对象，这些对象有一定的相似之处，那么就可以将他们封装起来，设置一个第三方工厂，直接在这个工厂类中根据调用方传递的参数生产相应的对象，这就是简单工厂。 简单工厂模式由三种角色组成。 工厂类：这个时本设计模式的核心角色，在简单工厂模式中含有一定的业务逻辑，根据逻辑的不同选择生成具体的产品。 抽象产品角色：它是所有产品的父类或者接口，具有所有产品共同的特性。 具体产品角色：工厂类生产的对象就是这些类的实例。 使用UML类图可以表示如下： 我们使用Java代码实现一下这个设计模式。加深映像。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114abstract class Operation &#123; private double numberA; private double numberB; public Operation(double numberA, double numberB) &#123; setNumberA(numberA); setNumberB(numberB); &#125; public double getNumberA() &#123; return numberA; &#125; public void setNumberA(double numberA) &#123; this.numberA = numberA; &#125; public double getNumberB() &#123; return numberB; &#125; public void setNumberB(double numberB) &#123; this.numberB = numberB; &#125; public abstract double getResult();&#125;class Add extends Operation &#123; public Add(double numberA, double numberB) &#123; super(numberA, numberB); &#125; @Override public double getResult() &#123; return super.getNumberA() + super.getNumberB(); &#125;&#125;class Sub extends Operation &#123; public Sub(double numberA, double numberB) &#123; super(numberA, numberB); &#125; @Override public double getResult() &#123; return super.getNumberA() - super.getNumberB(); &#125;&#125;class Mul extends Operation &#123; public Mul(double numberA, double numberB) &#123; super(numberA, numberB); &#125; @Override public double getResult() &#123; return super.getNumberA() * super.getNumberB(); &#125;&#125;class Div extends Operation &#123; public Div(double numberA, double numberB) &#123; super(numberA, numberB); &#125; @Override public double getResult() &#123; return super.getNumberA() / super.getNumberB(); &#125;&#125;enum OperationSign &#123; ADD, SUB, MUL, DIV;&#125;public class SimplyFactory &#123; public static Operation createOperate(double numberA, double numberB, OperationSign operate) &#123; Operation oper = null; switch (operate) &#123; case ADD: oper = new Add(numberA, numberB); break; case SUB: oper = new Sub(numberA, numberB); break; case MUL: oper = new Mul(numberA, numberB); break; case DIV: oper = new Div(numberA, numberB); break; &#125; return oper; &#125; public static void main(String args[])&#123; Operation addOper = SimplyFactory.createOperate(1.0,2.0,OperationSign.ADD); double addResult = addOper.getResult(); System.out.println(addResult); Operation subOper = SimplyFactory.createOperate(1.0,2.0,OperationSign.SUB); double subResult = subOper.getResult(); System.out.println(subResult); Operation mulOper = SimplyFactory.createOperate(1.0,2.0,OperationSign.MUL); double mulResult = mulOper.getResult(); System.out.println(mulResult); Operation divOper = SimplyFactory.createOperate(1.0,2.0,OperationSign.DIV); double divResult = divOper.getResult(); System.out.println(divResult); &#125;&#125; 工厂方法模式以上就是简单工厂的实现代码，但是回想我们学到的设计模式原则中的开闭原则，允许添加但是不允许修改，如果我想在加一个运算呢？是不是要修改createOperate方法。那么如何解决这个问题呢？那就再抽象一层，我们把原来在工厂类中直接生产具体对象的方式改成由方法类工厂去实现生产对象这个接口。这就是工厂方法模式。 工厂方法模式有以下成员组成： 工厂接口：定义了所有工厂具备的生产行为。 具体工厂类： 实现了工厂接口的生产方法，在这个类中生产具体的对象。 抽象产品角色：它是所有产品的父类或者接口，具有所有产品共同的特性。 具体产品角色：工厂类生产的对象就是这些类的实例。 使用UML类图可以如下表示： 使用代码的简单实现如下，该设计模式在简单工厂方法模式上再抽象了一层，很好的弥补了简单工厂方法模式违背的开闭原则，做到了增加工厂实现的时候不修改工厂的代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119package FactoryMethod;abstract class Operation&#123; private Double numberA; private Double numberB; public Operation(double numberA, double numberB)&#123; setNumberA(numberA); setNumberB(numberB); &#125; public Double getNumberA() &#123; return numberA; &#125; public void setNumberA(Double numberA) &#123; this.numberA = numberA; &#125; public Double getNumberB() &#123; return numberB; &#125; public void setNumberB(Double numberB) &#123; this.numberB = numberB; &#125; public abstract Double getResult();&#125;class AddOperation extends Operation &#123; public AddOperation(Double numberA, Double numberB)&#123; super(numberA,numberB); &#125; @Override public Double getResult() &#123; return super.getNumberA() + super.getNumberB(); &#125;&#125;class SubOperation extends Operation &#123; public SubOperation(Double numberA, Double numberB)&#123; super(numberA,numberB); &#125; @Override public Double getResult() &#123; return super.getNumberA() - super.getNumberB(); &#125;&#125;class MulOperation extends Operation &#123; public MulOperation(Double numberA, Double numberB)&#123; super(numberA,numberB); &#125; @Override public Double getResult() &#123; return super.getNumberA() * super.getNumberB(); &#125;&#125;class DivOperation extends Operation &#123; public DivOperation(Double numberA, Double numberB)&#123; super(numberA,numberB); &#125; @Override public Double getResult() &#123; return super.getNumberA() / super.getNumberB(); &#125;&#125;interface IFactory&#123; Operation CreateOperation(Double numberA, Double numberB);&#125;class AddFactory implements IFactory&#123; public Operation CreateOperation(Double numberA, Double numberB) &#123; return new AddOperation(numberA,numberB); &#125;&#125;class SubFactory implements IFactory&#123; public Operation CreateOperation(Double numberA, Double numberB) &#123; return new SubOperation(numberA,numberB); &#125;&#125;class MulFactory implements IFactory&#123; public Operation CreateOperation(Double numberA, Double numberB) &#123; return new MulOperation(numberA,numberB); &#125;&#125;class DivFactory implements IFactory&#123; public Operation CreateOperation(Double numberA, Double numberB) &#123; return new DivOperation(numberA,numberB); &#125;&#125;public class FactoryMethod &#123; public static void main(String args[])&#123; Double numberA = 10d; Double numberB = 20d; IFactory addFactory = new AddFactory(); Operation add = addFactory.CreateOperation(numberA,numberB); System.out.println(add.getResult()); IFactory subFactory = new SubFactory(); Operation sub = subFactory.CreateOperation(numberA,numberB); System.out.println(sub.getResult()); IFactory mulFactory = new MulFactory(); Operation mul = mulFactory.CreateOperation(numberA,numberB); System.out.println(mul.getResult()); IFactory divFactory = new DivFactory(); Operation div = divFactory.CreateOperation(numberA,numberB); System.out.println(div.getResult()); &#125;&#125; 抽象工厂模式既然在简单工厂的基础上单独抽象建造工厂可以构成工厂方法模式，那么生产的产品是否也是可以抽象的呢？所以就引出的本节的抽象工厂模式，如果生产的产品可以变化，那么是否可以直接抽象一个产品的接口出来呢？这个将具体的产品实现抽象的模式叫做抽象工厂模式。 角色如下： AbstractFactory：抽象工厂 ConcreteFactory：具体工厂 AbstractProduct：抽象产品 Product：具体产品 抽象工厂模式UML类图可以如下表示： 简单代码实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package AbstractFactory;abstract class Meat &#123; abstract String getMeat();&#125;class Beaf extends Meat &#123; private String name = "牛肉"; @Override public String getMeat() &#123; return this.name; &#125;&#125;class Fish extends Meat &#123; private String name = "鱼肉"; @Override public String getMeat() &#123; return this.name; &#125;&#125;abstract class Vegetables &#123; abstract String getVegetables();&#125;class Cabbage extends Vegetables &#123; private String name = "白菜"; @Override public String getVegetables() &#123; return this.name; &#125;&#125;class Tomato extends Vegetables &#123; private String name = "西红柿"; @Override public String getVegetables() &#123; return this.name; &#125;&#125;interface IEatFactory &#123; String eatMeat(); String eatVegetables();&#125;class Breakfast implements IEatFactory &#123; @Override public String eatMeat() &#123; Fish fish = new Fish(); return fish.getMeat(); &#125; @Override public String eatVegetables() &#123; Tomato tomato = new Tomato(); return tomato.getVegetables(); &#125;&#125;class Launch implements IEatFactory &#123; @Override public String eatMeat() &#123; Beaf beaf = new Beaf(); return beaf.getMeat(); &#125; @Override public String eatVegetables() &#123; Cabbage cabbage = new Cabbage(); return cabbage.getVegetables(); &#125;&#125;public class AbstactFactory &#123; public static void main(String args[]) &#123; IEatFactory launch = new Launch(); System.out.println("午餐吃的肉是：" + launch.eatMeat()); System.out.println("午餐吃的蔬菜是：" + launch.eatVegetables()); IEatFactory breakfash = new Breakfast(); System.out.println("早餐吃的肉是：" + breakfash.eatMeat()); System.out.println("早餐吃的蔬菜是：" + breakfash.eatVegetables()); &#125;&#125; 抽象工厂模式将产品抽象出来，客户端不需要知道具体的产品是如何生产的，不同的工厂生产不同的产品，比如数据库链接，底层是用Oracle还是Mysql实现不是客户端需要关心，底层也是可以随时替换的。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM常用虚拟机参数与分析]]></title>
    <url>%2F2019%2F10%2F19%2FJVM%E5%B8%B8%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%82%E6%95%B0%E4%B8%8E%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前段时间初步了解了JVM相关的书籍，读《深入理解JAVA虚拟机》。但是仅限与阅读，最近开始着手解决实际项目中的一些问题。 常用JVM参数设置我们在启动JAVA项目的时候时可以带启动参数的。无论是Tomcat，还是原生的JAVA项目。现在来总结一下常用的参数。 堆 -Xms 设置堆的最小空间大小，也是初始的大小 -Xmx 设置堆的最大空间大小，如果设置的与Xmx相同就是不会扩展堆内存 -Xmn 设置新生代的大小 -XX:NewSize 设置新生代初始大小 -XX:MaxNewSize 设置新生代的最大大小，和XX:NewSize合起来效果等于 -Xmn -XX:NewRatio 新生代和老年代大小的比值 -XX:SurvivorRatio 新生代中Eden区和Survivor区的大小比值，默认是4。也就是Eden:Survivor1:Survivor2 = 8:1:1 -XX:MaxTenuringThreshold 对象的年龄，即新生代的对象挺过多少次minor GC就可以进入老年代，默认是15。设置为0 就代表Survivor区没用了，存活对象直接进入老年代，所以一般会把这个值设置大一点，适合的对象使用适合的回收算法，只有活的够长，才有资格使用标记-整理算法。 -XX:PretenureSizeThreshold 还记得分配担保机制吗？如果对象比Survivor区还大，那么可以直接进入老年代，这个选项可以设置多大的内存可以直接进入老年代。 方法区方法区一般回收的效率很低，这里的内存是几乎不会回收的加载的类信息，常量，静态变量，即时编译器编译后的代码等数据，一般这些东西随程序启动而产生，随程序终止而消失，只有类的卸载才会清理方法区中的东西，但是类的卸载是十分不容易发生的，这在《深入理解JAVA虚拟机》中有介绍。Spring启动后在程序运行期间不会有太大的变动。 -XX:PermSize：方法区初始内存分配大小 -XX:MaxPermSize：方法区分配的内存的最大上限。 使用Linux命令进行JVM分析jstat命令首先通过ps 命令找到Java进程。 ps -ef | grep java 找到进程号PID后就可以使用jstat命令进行JVM状态的查看和分析。通过这个命令，我们能查看JVM在运行过程中的GC日志和实时的堆栈信息。参数很多，这里只是列举我常用的命令参数： -gcutil &lt;pid&gt; 统计GC情况。 -gc &lt;pid&gt; 统计GC堆目前的状态 -class(类加载器) &lt;pid&gt; 查看加载的类情况 jstat -gcutil &lt;pid&gt; :统计目前内存的使用情况以及GC情况 字段名称 字段意义 S0 第一个Survivor区域使用百分比 S1 第二个Survivor区域使用百分比 E Eden区使用百分比 O 老年代使用百分比 M 元空间（原永久代）使用百分比 CCS 类指针压缩空间的使用率 YGC 年轻代GC（Minor GC）的次数 YGCT 年轻代GC耗费的时间（单位为秒） FGC 全GC（FULL GC）的次数 FGCT 全GC所耗费的时间（单位为秒） GCT 全部GC所耗费的时间 YGCT+FGCT（单位为秒） jstat -gc &lt;pid&gt; :统计目前内存的使用情况以及GC情况 字段名称 字段意义 S0C 第一个Survivor区域容量（单位KB） S1C 第二个Survivor区域容量（单位KB） S0U 第一个Survivor区域已使用大小（单位KB） S1U 第二个Survivor区域已使用大小（单位KB） EC Eden区域容量（单位KB） EU Eden区域已使用容量（单位KB） OC 老年代容量（单位KB） OU 老年代已使用容量（单位KB） MC 元空间容量（单位KB） MU 元空间已使用容量（单位KB） CCSC 压缩类空间大小（单位KB） CCSU 压缩类空间使用大小（单位KB） YGC 年轻代回收次数 YGCT 年轻代GC耗费的时间（单位为秒） FGC 全GC（FULL GC）的次数 FGCT 全GC所耗费的时间（单位为秒） GCT 全部GC所耗费的时间 YGCT+FGCT（单位为秒） jstat -class &lt;pid&gt; :统计目前加载的类的情况 字段名称 字段意义 Loaded 装载的类的数量 Bytes 装载的类所占用的字节数 Unloaded 卸载的类数量 Bytes 卸载的类所占用的字节数 Time 装卸类所花费的时间 jinfo命令jinfo命令可以查看当前进程的虚拟机配置信息和系统变量。常用就一个参数 -flags。我们打出jinfo的命令信息 jinfo -flags &lt;pid&gt; 查看当前进程的虚拟机参数我们随便找一个Java进程具体看一下这个命令的结果是什么 上图我们看到的不正是本文开头讲的虚拟机参数么？堆的参数信息，一清二楚。通过这个命令，我们能快速的查看当前环境的JVM信息，有助于排查问题。]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8新特性——Stream流]]></title>
    <url>%2F2019%2F09%2F25%2FJava8%E6%96%B0%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94Stream%E6%B5%81%2F</url>
    <content type="text"><![CDATA[流是Java提供的一组操作集合的API，向流水线一样处理集合中的元素。元素流经过中间操作(intermediate operation)的处理，最后在终端操作(terminal operation)得到前面的处理结果。Stream流和Lambda表达式一样能够大大的提高开发效率。 流的简单使用承接上篇的Lambda表达式介绍。我们同样使用学生类来进行处理。 创建流有两种创建流的方法，我们经常会使用第一种。 调用集合的stream()方法或者parallelStream()方法创建流。 Stream类的静态of()方法创建流。 1234567List&lt;String&gt; createStream = new ArrayList&lt;&gt;();//顺序流Stream&lt;String&gt; stream = createStream.stream();//并行流Stream&lt;String&gt; parallelStream = createStream.parallelStream();//of()方法创建Stream&lt;String&gt; stringStream = Stream.of(createStream.toArray(new String[createStream.size()])); 流的分类流分为顺序流和并行流，并行流会使用多线程同时对集合中的多个元素进行处理，在使用并行流的时候要注意线程安全问题。 终端操作和中间操作终端操作会消费Stream流，并且产生一个结果，一旦被消费过了，就不被重用 中间操作会产生另外一个流，中间操作并不是立即发生的，在中间操作创建的新流执行完终端操作后，中间操作指定的操作才会发生，也就是延迟性。流的中间操作有无状态和有状态两种。 无状态表示元素之间互不影响，单独处理，和其他元素无关。 有状态表示元素之间是互相关联的，比如查找最小值最大值，排序，求和之类的操作。 常用流操作中间操作 distinct()，去重操作，将Stream流中的元素去重后，返回一个新的流。 filter(Predicate predicate)：筛选符合条件的元素后重新生成一个流。 map(Function mapper)：产生一个新流，对调用的流中的元素应用mapper，新流中包含这些元素，一般用作转换，或者单独抽出某个字段组成一个新的流。 sorted(Comparator) 将流按照Comparator排序。 peek(func) 把每个元素传入fun执行，执行后的元素组成一个新流。 终端操作 void forEach（Consumer action)：遍历流中的元素。（终端操作） Optional min(Comparator comparator)和Optional max(Comparator comparator)：获取流中的最大最小值，比较器可以自己定义。（终端操作） findFirst() 返回第一个元素。 findAny() 返回任意元素。用作随机元素提取。 anyMatch(Predicate) 任意元素匹配时返回true allMatch(Predicate) 所有元素匹配时返回true noneMatch(Predicate) 没有元素匹配时返回true reduce(func) 从流中计算某个值，接受一个二元函数作为累计器，从前两个元素开始持续应用它，累积器的中间结果作为第一个参数，流元素作为第二个参数。 reduce(a,fun) a为幺元值，作为累计器的起点 reduce(a,func1,func2) 与二元变形类似，并发操作中，当累积器的第一个参数与第二个参数都为流元素类型时，可以对各个中间结果也应用累积器进行合并，但是当累积器的第一个参数不是流元素类型而是类型T的时候，各个中间结果也为类型T，需要fun2来将各个中间结果进行合并 搜集器常用的搜集器如下： collect(Collector) iterator() 迭代器 forEach(fun) 遍历 toArray() 返回基本类型数组 Collectors.toList() 搜集流组成一个List Collectors.toSet() 搜集流组成一个Set Collectors.toMap(fun1,fun2) 搜集流组成一个Map,fun1是键，fun2是值 流使用例子使用上节我们使用的学生类进行举例1.按照成绩从小到大排序 1234List&lt;Student&gt; sort = students.stream() .sorted(Comparator.comparing(Student::getScore) .reversed()) .collect(Collectors.toList()); 2.取出所有成绩不及格的学生 123List&lt;Student&gt; filter = students.stream() .filter(student -&gt; student.getScore() &lt; 60) .collect(Collectors.toList()); 3.取出所有学生的名字 123List&lt;String&gt; map = students.stream() .map(Student::getName) .collect(Collectors.toList()); 4.取出前三个学生 12List&lt;Student&gt; limit = students.stream().limit(3) .collect(Collectors.toList()); 5.取出成绩最好的人 123Student max = students.stream().max( Comparator.comparing(Student::getScore)).get(); 6.有没有人考100分 123boolean anyMatch = students.stream().anyMatch( student -&gt; student.getScore().equals(100)); 7.统计及格的有多少人 123long count = students.stream().filter(str -&gt; student.getScore() &gt;= 60).count(); 8.对于不及格的学生，我们把它的成绩改成60 12345List&lt;Student&gt; peek = students.stream().peek(student -&gt;&#123; if(student.getScore() &lt; 60)&#123; student.setScore(60); &#125;&#125;).collect(Collectors.toList());]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8新特性——lambda表达式]]></title>
    <url>%2F2019%2F09%2F22%2FJava8%E6%96%B0%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[最近接触到lambda表达式，实在是太方便了，就在此总结一下。lambda表达式由三个部分组成。第一部分为一个括号内用逗号分隔的形式参数，参数是函数式接口里面方法的参数；第二部分为一个箭头符号：-&gt;；第三部分为方法体，可以是表达式和代码块，如果是代码块的话，需要使用{}将语句括起来。语法如下 12(paramterts) -&gt; expression;(int a, int b) -&gt; &#123;return a+b&#125;; 一个标准的例子如下： 12345678910// 匿名内部类Runnable r1 = new Runnable()&#123; @Override public void run()&#123; System.out.prinln("Hello world!"); &#125;&#125;//Lambda 表达式Runnable r1 = () -&gt; System.out.println("Hello world!"); 在上述的例子中，我们发现了Lambda表达式的好处，简洁，减少了很多的模板代码，同样的语义，Lambda表达式只需要关心具体的实现就可以了。 lambda表达式的本质lambda表达式本质是一个匿名函数。对于Java世界里一切都是对象来说有些另类，但是确实是Lambda表达式为Java引入了函数式编程的思想，虽然在具体实现中，Lambda表达式依附于一种特别的对象——函数式接口。Lambda表达式即没有声明的方法，也没有访问修饰符，返回值声明和名字。 函数式接口函数式接口就是只包含一个抽象方法的接口。Lambda表达式的本质就是实现一个函数式接口。传统的函数式接口实现可以如下表示： 1234567891011@FunctionalInterfaceinterface MylambdaInterface&#123; void doSomething(String s);&#125;public class MyInterfaceImpl implements MylambdaInterface&#123; @Override public void doSomething(String s)&#123; System.out.println(s); &#125;&#125; Lambda表达式实现如下： 1MyLambdaInterface test = (s) -&gt; System.out.println(s); Lambda表示式只能实现一个方法，所以他的目标类型只能是函数式接口 Lambda表达式可以直接将一段代码赋值给一个变量，这段代码，也就是箭头的右边就是接口的实现，左边就是接口的参数。等号左边就是函数的返回值。简洁清晰。 结合Stream的操作Lambda对于集合的操作是非常普遍的，它对于并行操作支持很好，能够大大简化代码的行数，缺点是省略的地方没写过Lambda表达式的人可能看不懂。举一些例子来看Lambda表达式操作集合的便携性，我们先看看什么是Stream。 Java8中的Stream是对集合(Collection)对象功能的增强，它专注于对集合对象进行各种非常便利，高效的聚合操作。而且Lambda表达式和Stream天然的支持并行程序，他们合作起来能够大大的提高程序的可维护性。Stream(流)更像是一个升级版本的迭代器。单向不可往复，像流水一样一去不复返。但是Stream可以作并行操作。展示几个常用的操作。 以学生类为例，学生有两个字段，name和score。 1.将所有不及格的学生单独抽一个List出来。 123public void notPassStudent(List&lt;Student&gt; students)&#123; List&lt;Student&gt; filterStudent = students.stream().filter(one -&gt; one.getScore() &lt; 60).collect(Collectors.toList());&#125; 而传统的方式是怎么做的呢？ 12345678public void notPassStudent(List&lt;Student&gt; students)&#123; List&lt;Student&gt; filterStudent = new ArrayList&lt;&gt;(); for(Student student: students)&#123; if(student.getScore() &lt; 60)&#123; filterStudent.add(student); &#125; &#125;&#125; 高下立判，用Lambda和Stream更加的简洁常用filter进行筛选的动作，后面将具体的学习Stream流的操作。现在我们只讨论使用场景。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垃圾搜集（三）——常用垃圾搜集器过程整理]]></title>
    <url>%2F2019%2F09%2F01%2F%E5%9E%83%E5%9C%BE%E6%90%9C%E9%9B%86%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E5%9E%83%E5%9C%BE%E6%90%9C%E9%9B%86%E5%99%A8%E8%BF%87%E7%A8%8B%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[上节总结了垃圾搜集算法，总觉得看书要能自己给自己讲一遍才能理解的透彻。那么具体在虚拟机中的垃圾搜集器是如何做的呢？具体步骤是什么？回忆第一节的内容，我们首先需要判定对象可以回收吗？然后再使用垃圾回收算法对堆中的内存进行整理。 对象的标记在第一节中总结了如何判定对象已死。目前虚拟机中都是使用的可达性分析算法。需要从GC Roots节点进行搜索，找到引用链。但是有个问题是，你在进行可达性分析的时候程序还是在运行着的，那么在分析过程中对象的引用关系还是在不停的变化着的，这样的话就不满足准确性和一致性。为了保证一致性，必须在逐个检查引用的时候停顿所有的Java执行线程。这个停顿叫做“Stop The World”。无论在那种垃圾搜集器中，这个过程是无法被避免的。 但是当线程停下来的时候虚拟机并不会一个不漏的检查所有的执行上下文和全局的引用位置，在HotSpot虚拟机中使用一组成为OopMap的数据结构，在类加载完成后，HotSpot就会把对象内偏移量上是什么类型的数据计算出来，这样在GC扫描的时候可以直接得知那些地方是引用类型。 安全点停顿线程并不是所有的地方都可以停顿，只有到达了安全点才能够进行停顿。但是是如何进行安全点的选择？安全点选定太少，GC等待时间就太长，选的太多，GC就过于频繁。选定原则是”具有让程序长时间执行的特征“，也就是在这个时刻现有的指令是可以复用的。一般选在方法调用、循环跳转、抛出异常的位置。 如何让线程在安全点停止呢？有两种方式。抢先式中断、主动式中断。 抢先式中断：GC发生时，中断所有线程，如果发现有线程不再安全点上，就恢复线程让它运行到安全点上。现在几乎不用这种方案。 主动式中断：设置一个标志，和安全点重合，再加上创建对象分配内存的地方。各个线程主动轮询这个标志，发现中断标志为真就挂起自己。HotSpot使用主动式中断。]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单理解Spring中的DI]]></title>
    <url>%2F2019%2F09%2F01%2F%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3Spring%E4%B8%AD%E7%9A%84DI%2F</url>
    <content type="text"><![CDATA[无论我们学的设计模式，还是要遵守的编码规范，都在强调一件事情，如何高效的进行开发。设计模式的宗旨是什么？设计出易维护，易扩展，易复用，灵活多样的应用。编码规范做了什么？设计一套科学的接口，大家都来依照这个接口的做法进行开发，高效的与他人进行合作。千奇百怪的编码风格自然会增加大家在评审代码的时候的难度。那么作为Java程序员必须学习的Spring究竟做了什么呢？我们一直在追求的一件事情就是代码的低耦合和高内聚。而Spring帮我们做了这件事情，大大的简化了Java开发。Spring时如何降低开发的复杂性的？ 基于POJO的轻量级和最小入侵性编程； 通过依赖注入和面向接口编程实现松耦合； 基于切面和惯例进行声明式编程； 通过切面和模板减少样板代码； 面试的时候都会问一个问题，什么是IOC，什么是AOP。这只是Spring的其中两个概念而已，我们具体学习Spring，是要看他到底是如何简化Java开发的。这里有两个名词： 依赖注入 组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中 控制反转 依赖双方都不互相控制，将对象的控制权交给第三方Spring来进行管理 实际来讲，并没有什么区别，即控制反转是由依赖注入来实现的。 依赖注入我们在刚开始学习Java的时候，如何操作对象之间的依赖关系呢？如果A依赖于B，那么在A中new一个B的对象就好了。但是这样有一个问题，耦合度太高了。new的时候需要指明包的名称，如果依赖的对象突然有变化，那就需要重新改，那就太麻烦了。如果此时有个第三方机构将这种依赖进行统一的管理，此时调用的一方就不用管被调用方的位置，只需用知道对方的名字和模样拿来直接用就行，具体这个类的位置，交给Spring来管理。 通常Spring 通过 @Autowired注解实现自动装配 依赖注入有三种方式，分别是构造器注入，接口注入和方法参数注入。来看他们的实现方式和区别。 接口注入通过将@Autowired注解放到需要注入的字段上面，这种注入方式使用的最多 12345678910@Servicepublic class UseFunctionService &#123; @Autowired FunctionService functionService; public String SayHello(String word)&#123; return functionService.sayHello(word); &#125;&#125; 优点：简洁明了，基本不改变代码 set方法注入通过将@Autowired注解放到set方法上 123456789101112131415161718@Servicepublic class UseFunctionService &#123; FunctionService functionService; @Autowired public void setFunctionService(FunctionService functionService) &#123; this.functionService = functionService; &#125; public FunctionService getFunctionService() &#123; return functionService; &#125; public String SayHello(String word)&#123; return functionService.sayHello(word); &#125;&#125; 不常见，特殊情况下需要在类加载后重新注入的话可以使用这个方式 构造器注入通过将 @Autowired注解放到构造器上方完成注入 1234567891011121314@Servicepublic class UseFunctionService &#123; FunctionService functionService; @Autowired public UseFunctionService(FunctionService functionService)&#123; this.functionService= functionService; &#125; public String SayHello(String word)&#123; return functionService.sayHello(word); &#125;&#125; 推荐使用构造器注入，优点如下： 依赖不可变 依赖不为空，当依赖的参数为空的时候启动会报错，解决忘记配置XML的疏忽，我就犯过一次错误，运行时报空指针错误半天没反应过来，后来单步调试才发现是依赖的对象为空，XML中忘记配置Bean了，这种情况的话使用构造器注入会在启动时报错。 完全初始化状态，在调用依赖时保证了依赖也是初始化完成的状态。 注册依赖注入是对所有的JavaBean进行操作，但是如何才能让Spring检测到你写的类呢？这就是bean的注册问题了。Spring是一个工厂，我们要将类放进这个工厂，才能委托Spring进行对象生命周期的管理。Spring 传统的方式是用XML进行bean的管理，这样的好处是进行了统一的管理。但是颇为麻烦，每次新加入一个服务还需要修改XML文件。这里推荐使用Springboot推荐的包自动扫描方式。 如何声明bean如何让你写的类被Spring容器找到，Springboot中一般有四种Bean的声明注解分别是： @Component 组件，没有明确的角色 @Service 在业务逻辑层使用，一般注册为一个服务 @Repository 在数据库访问层（dao）层使用,一般注册为数据库操作 @Controller 在展示层中使用，一般注册为对外的接口。 Spring如何检测到这些BeanSpringboot一般使用自动扫描的方式。具体在配置类中使用 Diconfig.java 123456789package com.sujunhao.Main;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan("com.sujunhao")public class DiConfig &#123;&#125; 使用@Configuration表示这是一个配置类使用@ComponentScan设置bean需要扫描的包 Main.java 123456789101112131415package com.sujunhao.Main;import com.sujunhao.Service.UseFunctionService;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class Main &#123; public static void main(String[] args)&#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(DiConfig.class); UseFunctionService useFunctionService = context.getBean(UseFunctionService.class); System.out.println(useFunctionService.SayHello("helloword")); context.close(); &#125;&#125; 在Main中使用AnnotationConfigApplicationContext作为Spring容器，加载Spring应用上下文，使用配置类作为初始化的参数，避免使用application.xml进行配置，这是一种相当简介的办法。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垃圾搜集（二）——常用垃圾回收算法]]></title>
    <url>%2F2019%2F08%2F25%2F%E5%9E%83%E5%9C%BE%E6%90%9C%E9%9B%86%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[标记-清除算法算法分为两个部分：标记和清除。首先标记出需要回收的对象，然后统一的回收。 问题如下： 效率太低，标记和清除两个步骤的效率都不高。 该算法完成后会产生大量的内存不连续碎片，碎片太多会导致后来再进行分配大对象时无法得到足够的内存而不得不再触发一次垃圾搜集动作。 复制算法 复制算法解决了效率的问题，复制算法的思想是将内存区域分成两块，每次只使用其中的一块，当这一块的内存使用完了的时候就将标记存活的对象复制到另一块内存中去。然后统一清除这一块使用的内存。这种方法高效且简单，根本不用考虑内存碎片的情况，但是代价时将使用的内存缩小到了原来的一半。 但是新生代中的对象都有一个特性就是朝生夕死，所以基本每次回收都能够回收绝大部分的内存。商用虚拟机中的新生代回收算法并不是按照1:1来进行划分的。它将新生代分为较大的Eden区和两块较小的Survivor区，每次使用Eden和其中的一块Survivor。每次回收使用中的内存，统一复制到未使用的Survivor中。然后将Eden和Survivor清空。HotSpot虚拟机的比例是8:1。当Survivor不够用的时候，会直接通过分配担保机制进入老年代。如何分配担保请点击这里。 问题如下： 会浪费掉一定的内存，但是现在内存足够大，浪费掉的不值一提。 如果回收过后的内存大于Survivor的空间，会放不下，但是解决办法是使用分配担保机制将内存直接放入老年代。 标记-整理算法标记整理算法适合那种对象存活率较高的内存区域，比如老年代，如果老年代依然使用复制算法的话，效率太低。且老年代的内存比较稳定且大，如果使用复制算法，会导致出现所有对象都存活的极端情况，导致效率又低时间又慢。所以老年代一般使用的就是标记整理算法。 标记整理，顾名思义就是先标记，再整理。首先让所有标记存活的对象那个向一端移动，然后直接清理掉头指针以外的区域就行了，相当于整理的动作。 总结每个Java对象的生命周期是不一样的。新生代都是朝生夕死的对象，老年代的对象一般也是长期存活的。当新生代的Survivor区某个对象存活一定的次数后就可以将它移动到老年代。且不同的区域应该使用不同的算法，新生代使用复制算法，效率高又快，老年代使用标记整理算法，这就是分代搜集的思想。]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垃圾搜集（一）——如何判定对象已死]]></title>
    <url>%2F2019%2F08%2F25%2F%E5%9E%83%E5%9C%BE%E6%90%9C%E9%9B%86%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%A6%82%E4%BD%95%E5%88%A4%E5%AE%9A%E5%AF%B9%E8%B1%A1%E5%B7%B2%E6%AD%BB%2F</url>
    <content type="text"><![CDATA[垃圾回收是Java的一大特色，这个特性让程序员可以不用像C++一样思考在哪里写delete语句来释放new出来的内存。就算是这样，我们也得学习Java虚拟机到底是如何做到的，不至于在程序出问题时拿着GC日志看不懂。本文总结三个问题。 那些内存需要回收？ 什么时候回收？ 如何回收？ 我们首先来回忆Java运行时数据区的各个部分，虚拟机栈，程序计数器，本地方法栈（和虚拟机栈合并）三个区域是线程私有的，随线程生而开辟，随线程灭而消亡。虚拟机栈在线程执行时，方法不停的出栈入栈，每一个栈帧分配多少内存已经由类结构确定了，方法出栈的时候这部分内存自然就释放了。反应到代码就是方法内局部变量（不是对象），那些内存区域直接开辟在栈帧里面的变量。所以，需要回收的内存区域就是堆和方法区这些线程共享的区域。在进行垃圾搜集时，垃圾搜集器就是对堆和方法区进行操作。在HotSpot虚拟机中，方法区也叫作永久代，和堆没关系。堆=新生代+老年代。而垃圾搜集是发生在新生代，老年代和永久代之中的行为。以下是Java堆结构图 Java线程共享的区域中，Java堆分为新生代和老年代，其中新生代分为Eden区（存放新生对象），两个幸存区（From Survivor和To Survivor）（存放每次垃圾回收后存活的对象）。为什么这么设置呢？复制算法中会讲到。 如何判定对象是否需要回收引用计数法垃圾搜集器在对堆做回收动作之前，总得知道那些对象是可以回收的，那些则不能回收。最简单的方法是引用计数法（Reference Counting）具体做法就是给对象添加一个引用计数器，每当有一个地方引用它时，就给这个引用计数器加1；当引用失效时，计数器就减1。如果计数器为0了，就表示这个对象已经不再使用了。方法简单，但是有一个缺点是不能解决循环引用，如果两个对象互相引用的话，他们的计数器就永远不能为0。 可达性分析算法（Reachability Analysis）主流的GC搜集器的基本思路就是可达性分析，基本思路如下：通过一系列的“GC Roots”的对象作为起始点，从这些节点向下搜索，会产生一个图型结构，或者是树型结构。如果一个对象不在任何的引用链中，则表示对象已经不再使用。 Java中常用的GC Roots对象如下： 虚拟机栈（栈帧中的本地变量表）中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI（Native方法）引用的对象 方法区回收由于方法区存储着类的信息，类的回收一般性价比很低，在新生代中，有很多对象都是朝生夕死，一次回收会有70%~95%的空间。永久代的效率则非常低。在方法区中主要回收两部分内容。废弃的常量和无用的类，常量池的回收非常简单，如果当前系统没有对象引用常量池中的内容，那么这个常量就是可以回收的状态。 废弃的类的要求就比较严格。 该类的所有实例都已经被回收，Java堆中不存在该类的任何实例 加载该类的ClassLoader已经被回收 该类对应的java.lang.Class对象没有在任何地方被引用，无法通过反射访问类的方法。]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式几大原则]]></title>
    <url>%2F2019%2F08%2F24%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%87%A0%E5%A4%A7%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[六大原则 单一职责原则 里氏替换原则 依赖倒转原则 开放-封闭原则 接口隔离原则 迪米特法则 设计模式的目标 易维护，易扩展，易复用，灵活多样。 单一职责原则 单一职责原则，就一个类而言，应该仅有一个引起它变化的原因。 如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭到意想不到的破坏。 软件设计真正要做的很多内容，就是发现职责并把那些职责相互分离，如何判断是否应该分离出类来，如果你能够想到多于一个的动机去改变一个类，那么这个类就具有了多于一个的职责。此时就应该考虑职责的分离。 依赖倒转原则 依赖倒转原则A. 高层模块不应该依赖低层模块。两个都应该依赖抽象。B. 抽象不应该依赖细节。细节应该依赖抽象。 说白了，依赖倒转原则就是要针对接口编程，不要针对实现编程。最好每个类都要有接口，或者抽象类。面对接口编程能够减少类之间的耦合度。高层模块不应该依赖低层模块，两个都应该依赖抽象。 里氏替换原则 里氏替换原则：子类型必须能够替换掉他们的父类型。 在一个软件实体中如果使用的是父类的话，那么一定适用于其子类，而且察觉不到父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化。 只有当子类可以替换掉父类时，软件单位的功能不受到影响时，父类才能真正的被复用，而子类也能够在父类的基础上增加新的行为，子类最好不要重写父类的方法，而是增加父类的行为。正式由于子类型的可替换星才使得父类类型的模块在无需修改的情况下就可以扩展。 开放-封闭原则 开放-封闭原则，软件实体（类，模块，函数等等）应该可以扩展，但是不可修改。 对于扩展是开放的，对于修改是封闭的。对于需求一直变化的系统，我们都不要去修改原有的逻辑，而是增加新的逻辑。对于新需求一来就要把整个程序推到重来时不可取也是不现实的，所以开闭原则告诉我们，在程序设计的时候要时刻考虑，尽量让这个类足够好，写好了就不要去修改，如果有新的需求，增加一些类就完事了，原来的代码能不动就不动。 开放封闭原则时面向对象设计的核心所在，遵循这个原则可以带来面向对象技术所称的巨大好处 可维护，可复用，可扩展，灵活性好 开发人员应该仅对程序中呈现出频繁变化的哪些部分做出抽象，然而，对于应用程序中的每个部分都刻意地进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。 接口隔离原则 接口隔离原则A.客户端不应该依赖它不需要的接口B.类间的依赖关系应该建立在最小的接口上 不要在一个接口里面放很多的方法，这样会显得这个类很臃肿不堪。接口应该尽量细化，一个接口对应一个功能模块，同时接口里面的方法应该尽可能的少，使接口更加轻便灵活。或许看到接口隔离原则这样的定义很多人会觉得和单一职责原则很像，但是这两个原则还是有着很鲜明的区别。接口隔离原则和单一职责原则的审视角度是不同的，单一职责原则要求类和接口职责单一，注重的是职责，是业务逻辑上的划分，而接口隔离原则要求方法要尽可能的少，是在接口设计上的考虑。 迪米特法则 迪米特法则，如果两个类不必彼此直接通信，那么这个两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。 首先在累的结构设计上，每一个类都应当尽量降低成员的访问权限。 类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几大基础排序算法复习]]></title>
    <url>%2F2019%2F08%2F17%2F%E5%87%A0%E5%A4%A7%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[大学也毕业了，呆了一段时间公司，干的活多是琐碎的工作，提高了项目能力，但是对于编程基础的东西绝对不能丢，就像项目组最近在排查性能问题一样，如果程序员的基础扎实了，很难会出现性能的问题，节省时间和空间几乎成了本能的行为，又怎么会出现项目迭代过程中专门花时间进行性能瓶颈的排查呢？项目几经易手，原来的代码难改，逻辑混乱，对于业务不太熟悉的人来说，代码根本无从下手。所以就像破窗户一样只会越来越大。 不要容忍破窗户 出自《程序员修炼之——从小工到专家》 所以我准备系统的复习大学期间的算法知识。先从常用的排序和查找开始。 冒泡排序冒泡排序是大学中学习C++后接触到的的第一个算法，算法思想是每次比较相邻的两个数，大的向后排，不停的后移，每经过一轮，就会有一个大数冒到最后去，俗称冒泡法。这是个稳定的排序算法，无论数据如何排列，程序经过的步骤是一样的。不会因为数据的排列不同而少做处理。 算法实现123456789101112131415161718192021222324//冒泡排序void bubble_sort(int *array,int length)&#123; if(array == NULL)&#123; return; &#125; int flag=1; //flag的作用是记录上一轮是否发生了交换， //如果没有，那就说明已经排好了序，直接退出 for (int i = 0; i &lt; length - 1&amp;&amp;flag; i++) &#123; flag=0; for (int j = 0; j &lt; length - i - 1; j++) &#123; if (array[j] &gt; array[j+1]) &#123; int temp = array[j]; array[j] = array[j+1]; array[j+1] = temp; flag=1; &#125; &#125; &#125;&#125; 思路整理原始的冒泡排序是这样的，两层循环，外层执行一次表示一轮，每执行一次都代表了一个大数已经冒出去了，内层循环表示相邻两个数之间的比较，并且比较的指针位置随着循环的执行在不停地向后移动。循环中if判断表示两个数之间交换位置。上述方法和课本学习的原始冒泡排序不太一样，他加入了一个标志位flag，这个标志位记录了本轮有没有进行过数字位置的变动，如果进行到某一轮，每一个数的位置都没有发生变化，那么就代表所有的数字都已经到了他该放置的位置。所以排序就结束了，直接退出循环。 最佳情况：O(n) 最差情况：O(n^2) 平均时间复杂度：O(n^2) 空间复杂度为O(1) 稳定排序算法 插入排序插入排序使用了和冒泡不一样的思想，他的思路不是冒泡那种根据频繁变动位置来处理，而是在一轮中拿出一个基准值来进行判断。他的思路是这样的，默认第一轮最左边的数是最小的，所以第一轮不进行，直接拿左数第二个数作为第一个基准值。并对已经排序的数组中从右向左比较，如果比这个数大，向后挪一个位置，相当于占用了刚刚基准值的位置，直到找到一个位置上的数比基准值小，那么基准值就插入到这个数的后面，如果比这个基准值小，那么前面的所有数都比这个基准值小，本轮结束。直到所有的数都作为基准值进行过一侧比较，整个算法结束。 算法实现123456789101112131415161718//插入排序void insert_sort(int *array,int length)&#123; if(array == NULL)&#123; return; &#125; for(int i=1;i&lt;length;i++) &#123; int j=i-1; int temp=array[i]; while(array[j]&gt;temp&amp;&amp;j&gt;=0) &#123; array[j+1]=array[j]; j--; &#125; array[j+1]=temp; &#125;&#125; 算法分析 最佳情况：O(n) 最坏情况：O(n^2) 平均时间复杂度：O(n^2) 空间复杂度：O(1) 稳定排序算法 快速排序快速排序是一个对冒泡排序的一大改进，冒泡排序采用的是挨个比较的办法，快速排序的思想则是分治法，取出一个数，将所有比这个数小的放在左边，比这个数大的放在右边。这样会产生两个子数组，然后在这两个子数组中分别再采用相同的策略，直到不能再分，这样处理的步骤会比冒泡排序少很多。采用的是分治递归的思想。 那么如何处理基准值比较这个逻辑呢？常用的是挖坑法。取出头部第一个数，设置头尾两个指针，先从尾部开始向前移动尾指针，出现第一个比基准数小的数就放置在基准数留下的坑中，此时该数的原始位置就成了一个新的坑位。然后再从头部向后移动头部指针，将第一个大于基准数的数向后挪，放置在刚刚新的坑位上。这样交替移动头尾指针，直到最后头尾指针相遇，此时最后一个坑位就是相遇的地方，将基准数填到这个位置，一轮排序就结束了。 然后使用相同的策略对基准数左右的两个子数组进行排序，同样是调用一轮排序的算法。只不过把左子数组的尾指针换成第一轮的基准数左边的位置，把右子数组的头指针换成了基准数右边的位置而已。直到递归的把所有的数全部排完。 算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//快速排序int quick_sort(int *array,int _left,int _right)&#123; //挖坑法 if(_left&lt;_right)&#123; int left=_left;//左指针 int right=_right;//右指针 int key=array[_left];//将数组第一个数作为基准值 while(left&lt;right)&#123; while(right&gt;left&amp;&amp;key&lt;=array[right])&#123; //从右向左找到第一个小于基准值的值 right--; &#125; array[left]=array[right]; //将右指针的值赋给左指针，第一次会覆盖基准值 while(right&gt;left&amp;&amp;key&gt;=array[left])&#123; //从左向右找到第一个大于基准值的值 left++; &#125; array[right]=array[left]; //将左指针的值赋给右指针，会覆盖掉刚刚右指针多出来的旧位置 &#125; array[left]=key;//最后左右指针归于中间一处，此处放回基准值 return left; &#125;&#125;//快速排序递归实现void quick_sort_recursion(int *array,int left,int right)&#123; if(left&gt;right) return; int index = quick_sort(array,left,right); quick_sort_recursion(array,left,index-1); quick_sort_recursion(array,index+1,right);&#125;//快速排序非递归实现void quick_sort_Not_recursion(int *array,int left,int right)&#123; if(left&gt;=right) return; stack&lt;int&gt; s;//辅助栈，代替调用栈，防止调用栈溢出 s.push(left); s.push(right);//后入的right，所以要先拿right while(!s.empty())//栈不为空 &#123; int right = s.top(); s.pop(); int left = s.top(); s.pop(); int index = quick_sort(array,left,right); if((index - 1) &gt; left)//左子序列 &#123; s.push(left); s.push(index - 1); &#125; if((index + 1) &lt; right)//右子序列 &#123; s.push(index + 1); s.push(right); &#125; &#125;&#125; 算法分析上述的代码分别展示了递归和非递归两种排序策略，每一轮排序过后，会返回一个两个子数组的分界点。之后再继续使用新的左右指针位置调用这个函数。先左后右的思路，但是这个是使用的系统的调用栈，如果深度过多容易造成调用栈溢出。所以我们使用非递归的方法，其实就是自己定义一个栈用来模拟调用栈的行为。 非递归的思路如下： 在循环开始前初始化左右两个指针位置分别压栈。 判断栈是否为空，为空则表示排序结束。 不为空时分别按照栈的顺序出栈，使用出栈的指针位置进行一轮排序。 拿到新的基准数位置作为新的指针位置。 如果左右指针位置不相等，分别按照左，右的位置将两个子数组的指针位置进栈，如果相等表示最小的子数组也排序完成，什么都不做。 循环2-5。 最佳情况：O(nlogn) 最坏情况：O(n^2) 平均时间复杂度：O(nlogn) 空间复杂度：O(nlogn) 不稳定排序算法 希尔排序希尔排序是一个改进的插入排序，通过将数组进行分组的方式提高排序的效率，一般我们将数组长度的一半作为初始步长。然后在每一组中按照插入排序的方式进行排序。最后通过不断的缩小步长来进行区域的排序。这种排序方式比直接插入排序的效率高。 算法实现12345678910111213141516171819202122232425//希尔排序void shell_sort(int *array,int length)&#123; int distance = length/2; while(distance&gt;=1) &#123; //整个是一个插入排序 for(int i=distance;i&lt;length;i++)//按照增量分组 &#123; int j=i-distance;//前面的数的位置 int temp=array[i];//将后面的数存一份 while(j&gt;=0 &amp;&amp; temp&lt;array[j])//前面是数不越界且前面的大 &#123; //前面的大数给后面 array[j+distance]=array[j]; //继续向前找当前组的前一个数 j=j-distance; &#125; //排序后把后面的数放在正确的位置 array[j+distance]=temp; &#125; distance=distance/2;//缩小增量，直到为1 &#125;&#125; 算法分析 最佳情况：O(nlogn) 最坏情况：O(nlogn) 平均时间复杂度：O(nlogn) 空间复杂度：O(1) 不稳定排序算法 堆排序什么是堆堆是一个近似与完全二叉树的数据结构。 完全二叉树: 除了最后一层之外的其他每一层都被完全填充，并且所有的节点都保持左对齐。 堆排序就是利用完全二叉数的特性来进行排序的算法分。堆分为最大堆和最小堆。 最大堆要求节点的元素都大于等于其孩子 最小堆要求节点的元素都小于等于其孩子 如何利用数组进行建堆呢？首先要了解数组和堆中节点的对应关系，在堆中是如何表示数组的位置的。根据完全二叉树的特点 array[left] = array[father] * 2 + 1 array[right] = array[father] * 2 +2 如何建立最大堆和最小堆，这里以最大堆为例。从最后的非叶子节点开始，分别和左右孩子进行比较，并将最大的数放置在父节点位置，从后向前，对每一个非叶子节点都进行这种操作，这样每次上层的父节点进行交换的时候保证了他的子节点是比孙子大的。避免了频繁交换的麻烦。这样每次建最大堆都最多交换非叶子节点的个数那么多次。 每建立一次最大堆，就将堆顶的元素取出，表示这里是最大的数，与数组的最后一个位置交换位置，将尾节点交换到根的位置，并将数组的最后一个数剔除出建堆的元素。表示这个数已经排序完成。 算法实现12345678910111213141516171819202122232425262728293031323334//堆排序构建堆函数void adjust(int *array, int length, int index)&#123; int left = 2*index + 1;//左子树 int right = 2*index + 2;//右子树 int maxIndex = index;//定义最大值默认非叶节点 if(left&lt;length &amp;&amp; array[left] &gt; array[maxIndex]) maxIndex = left; //如果左边大，最大的是左边 if(right&lt;length &amp;&amp; array[right] &gt; array[maxIndex]) maxIndex = right; // maxIndex是3个数中最大数的下标 if(maxIndex != index) // 如果maxIndex的值有更新 &#123; int temp = array[maxIndex]; array[index]=array[maxIndex];duiz array[maxIndex]=temp; adjust(array, length, maxIndex); // 递归调整其他不满足堆性质的部分 &#125;&#125;void heap_sort(int *array, int length)&#123; for(int i=length/2 - 1; i &gt;= 0; i--) // 对每一个非叶结点进行堆调整(从最后一个非叶结点开始) &#123; adjust(array, length, i); &#125; for(int i = length - 1; i &gt;= 1; i--) &#123; swap(array[0], array[i]); int temp = array[0]; array[0]=array[i]; array[i]=temp; // 将当前最大的放置到数组末尾 adjust(array, i, 0); // 将未完成排序的部分继续进行堆排序 &#125;&#125; 算法分析 最佳情况：O(nlogn) 最坏情况：O(nlogn) 平均时间复杂度：O(nlogn) 空间复杂度：O(1) 不稳定排序算法 选择排序选择排序的思路非常的简单，符合常人的排序思路，每次从待排序的数组中抽出最小的数放入坑位，如果位置本身就是最小的数，什么都不做。直到待排序数组为空。 算法实现12345678910111213141516171819202122//选择排序，最简单的思路void select_sort(int *array,int length)&#123; //每次从待排序的数组中找到最小的，放在下标的位置，稳定算法（无论是什么样的数组，排序次数不变） for(int i=0;i&lt;length;i++) &#123; int min_index=i; for(int j=i+1;j&lt;length;j++) &#123; if(array[min_index]&gt;array[j]) &#123; min_index=j; &#125; &#125; if(min_index!=i) &#123; int temp=array[i]; array[i]=array[min_index]; array[min_index]=temp; &#125; &#125;&#125; 最佳情况：O(n^2) 最差情况：O(n^2) 平均时间复杂度：O(n^2) 空间复杂度：O(1) 不稳定排序算法 归并排序归并排序采用分治的思想，首先对数组进行划分，直到不能再进行细分，然后将临近的数组进行组合同时排序，使用一个辅助数组，两个子数组的头谁小谁进，直到两个子数组为空，表示合并完成，采用递归的方法，将所有的子数组和并完成的时候数组也就排序完成了。 算法实现123456789101112131415161718192021222324252627282930313233343536373839//归并排序，在两个下标之间合成一个有序序列void merge(int *array,int first,int mid,int last)&#123; int i=first;//第一个子数组首元素 int j=mid+1;//第二个子数组首元素 int m=mid;//第一个子数组尾元素 int n=last;//第二个子数组尾元素 int temp[n];//辅助数组 int k=0;//辅助数组下标 //两个子数组头部，谁小谁进辅助数组,合成一个有序数组 while(i&lt;=m&amp;&amp;j&lt;=n) &#123; if(array[i]&lt;array[j]) temp[k++] = array[i++]; else temp[k++] = array[j++]; &#125; //两个数组有剩余时，直接进辅助数组 while(i&lt;=m) temp[k++]=array[i++]; while(j&lt;=n) temp[k++]=array[j++]; //将辅助数组送回数组 for(i=0;i&lt;k;i++) array[first+i]=temp[i];&#125;// 递归的进行两两分割void merge_sort(int *array,int start,int end)&#123; if(start &lt;end) &#123; int mid=(start+end)/2; merge_sort(array,start,mid);//分割左子数组 merge_sort(array,mid+1,end);//分割右子数组 merge(array,start,mid,end); &#125;&#125; 算法分析 最佳情况：O(nlogn) 最坏情况：O(nlogn) 平均时间复杂度：O(nlogn) 空间复杂度：O(n) 稳定排序算法]]></content>
      <categories>
        <category>算法复习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML类图]]></title>
    <url>%2F2019%2F08%2F05%2FUML%E7%B1%BB%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[类的表示在面向对象的设计方法中，类一般分为三个部分。类名，类属性，和类方法。在面向对象的设计语言中，一个完整的类是需要包含这些方法的。使用类图表示就是下图：Person代表类名，在第一栏，如果是抽象类就用斜体显示。第二栏代表了类的属性，第三栏代表了方法。’+’代表public，’-‘代表private，’#’表示protected。 上图中接口与类图的区别就是顶端有&lt;&lt;interface&gt;&gt;显示。第一栏是接口名称，第二栏列出了接口方法。 类之间的关系类图是面向对象系统建模中最常用和最重要的图，通过画类图可以很清晰的展示系统的设计。类和类之间有六种关系，分别是泛化(Generalization)，实现(Realization)，依赖(Dependency)和关联(Association)，聚合(Aggregation)和组合(Composition)。 虚线箭头指依赖 实线箭头指关联 虚线三角指接口 实线三角指父类 空心菱形是聚合 实心菱形是组合 依赖(Dependency)依赖 是几种关系中耦合度最小的，如下图：氧气类和动物类本身并没有什么关系，只是动物类的某些方法会使用到氧气类，它本身并不是动物类的某个属性，只是某些方法需要使用到而已。具体的代码表现形式就是动物的某个方法需要用到氧气，作为局部变量或者参数。 12345class Animal &#123; public void breath(Oxygen o2)&#123; &#125;&#125; 或者 12345class Animal&#123; public void breath()&#123; Oxygen o2 = new Oxygen(); &#125;&#125; 上述的氧气类对象只是动物类的某个方法持有而不是动物类，只有执行呼吸方法的时候氧气对象才会别初始化，生命周期随方法的结束而结束。 关联(Association) 关联比依赖的耦合度高，一般是一个类是另一个类的一个属性。比如企鹅和气候，企鹅需要知道气候的变换和规律，是和类相关的。气候类伴随着企鹅的生命周期的全过程。具体的代码表现形式就是： 123class Penguin&#123; private Climate climate;&#125; 在企鹅类中，用到了气候对象。 泛化(Generalization)泛化说白了就是某个东西的具体实现，那么在面向对象中就是继承的关系。某个类是父类的具体实现，他们就是泛化关系：泛化就是继承关系，使用实线三角来表示。具体到代码表现就是： 123public class Bird extends Animal&#123;&#125; 实现(Realization)实现表示的是接口。某个类实现了某个接口，使用虚线三角来表示。具体到代码实现是： 123public class WIdeGoose implements Fly&#123;&#125; 组装(Composition)这里为什么要使用组装呢？很多人把组合和聚合分不清楚。组合就是使用不同的零件来组成一件东西。而聚合则是将多个一样的东西合在一起。使用组装则更容易来区分这个概念。组装使用实线菱形来表示。如上图，一只鸟有两只翅膀，是1对2的关系。翅膀是鸟的组成部分之一。具体到代码实现是： 123456class Bird&#123; private Wing wing; public Bird()&#123; wing = new Wing(); &#125;&#125; 在鸟这个对象初始化之时翅膀就要作为鸟初始化的一部分。 聚合(Aggregation)聚合是一种很好理解的关系，我们写代码会经常用到，数组，列表等集合就是聚合关系的表现形式。上图大雁组成雁群，少一只大雁雁群依然是存在的。代码表现形式如下： 123class WideGooseAggregate&#123; private WideGoose[] arrayWideGoose;&#125; 在雁群类中，有大雁的集合对象。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java如何创建一个对象]]></title>
    <url>%2F2019%2F07%2F27%2FJava%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[我们知道Java是面向对象的编码思维，但是你知道一个new语句到底做了什么吗?一个对象到底是如何进行创建，布局和访问的。 对象的创建 第一步，首先虚拟机在在遇到一条new语句的时候，首先会检查这个指令的参数是否能在常量池中定位到一个类的符号引用。并且将检查这个符号引用代表的类是否已经被加载，解析和初始化过。如果没有，则必须对这个类进行类加载。 第二步，类加载完成后，JVM会在java堆上为对象分配内存，内存大小在类加载的时候就已经确定了（这个是如何确定的呢？类加载完成以后，类的继承体系关系就确定了，因为在加载该类之前是要先加载父类的，所以对象的大小=对象头大小+父级继承链非静态成员域大小+当前加载类非静态成员域大小+内存对齐导致的padding。）。从堆中分配内存有两种方式，指针碰撞和空闲列表。 第三步，初始化，将分配的内存区域初始化为零，不同类型有不同的初始化值。保证对象的字段不初始化也可使用。 第四部，执行构造方法，这一步就是执行用户自定义的初始化方法，对数据进行初始化，至此对象创建完成。 指针碰撞和空闲列表指针碰撞如果内存规整，没有碎片，指针碰撞是一个很好的方法。将已使用的内存和未使用的内存分别分布在一个指针的两侧，这个指针就是一个分界点，当需要分配内存的时候，就将指针向空闲的一端移动与内存大小相同的距离。使用的GC搜集器：Serial, ParNew 空闲列表如果内存是不规整的，有大量的碎片存在，JVM就维护一个列表，记录可用的内存块信息，当分配内存的操作发生的时候，就在这个列表中找到一个足够大的内存块分配给对象，并更新表格。使用的GC搜集器：CMS 如何进行选择内存分配方式选择那种分配方式是由Java堆是否规整决定的，而Java堆是否规整又是由所采用的垃圾搜集器是否带有压缩整理算法决定的。同时，还需要考虑对象创建在虚拟机中是非常频繁的行为，需要考虑线程安全的问题，指针碰撞会产生线程之间的冲突，一般解决办法是首先，保证了分配内存操作的原子性，然后预先为每个线程分配一小块内存，保证了他们之间互相不冲突。这块内存叫做本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)。只有该线程用完了TLAB时，才需要同步锁定。虚拟机是否使用TLAB，由选项–XX:+/UseTLAB参数决定。 对象的内存分布对象在内存中分为3个部分，分别是对象头，实例数据，以及对齐填充。 对象头对象头主要分为Mark Word和类型指针。MardWord存储了哈希吗GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID等。这部分数据长度在32、64位虚拟机内分别是32bit和64bit。类型指针指向类元数据的指针，用来确定对象是那一个类的实例。对象头是一个非固定的数据结构。如果对象是一个数组，对象头还要有一块用于记录数组长度的数据。 实例数据实例数据就是对象中定义的数据已经从父类继承的数据。 对齐填充HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，所以必须要使用对齐填充来进行占位。保证对象的大小是8字节的整数倍。 对象的访问定位对象在创建完之后，放在java堆中，但是是如何找到这个对象的呢？分为直接地址和句柄 句柄在java堆中，会划分一个区域叫做句柄池，引用类型reference中存储的就是对象的句柄地址，句柄包含了对象的具体地址信息。移动对象不需要修改数据。 直接地址reference中直接存储对象的地址。速度快。]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Try-with-Resources]]></title>
    <url>%2F2019%2F07%2F24%2FTry-with-Resources%2F</url>
    <content type="text"><![CDATA[Java语法糖是一种在不影响功能的情况下为程序员提供的便捷的语法使用方式。 Tye-with-Resources就是这样一个用来便捷的在try语句块中申请和释放资源的语法使用方式。通过这个语法糖,可以有效的避免在finally中忘记释放资源的情况。类似的思想在Python的with语法中也有体现。推荐一个IDEA插件，sonarlint。通过sonarlint的智能提示，我们可以改正很多的不好的编码习惯。 资源什么是资源，对于非内存的操作，比如磁盘，数据库，比如网络等其他设备。都有一个临界资源的概念。什么是临界资源？在操作系统知识体系中，把一次只能由一个进程使用的资源称为临界资源，所以所有的进程使用这些资源的时候都是互斥的。那么我们在编程的时候，一定要注意临界资源的申请和释放。 try-catch-finally方式传统的资源申请方式是在try中申请，在catch中处理异常，在finally中释放资源。但是程序毕竟是人写的，总会有遗忘的时候。当程序员遗忘后，Java编译器是不会报错的，但是会出bug。try-catch-finally方式如下： 1234567891011121314public static void method()&#123; InputStream inputStream=null; try &#123; inputStream= new FileInputStream("test"); &#125; catch (Exception e) &#123; &#125; finally &#123; try &#123; inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 在上述的代码中，关闭资源的方式非常繁琐。容易遗忘。 try-with-Resources 方法try-with-Resources 是JDK1.7之后的语法糖。旨在简化这种繁琐的关闭资源的方式。代码如下： 123456789//捕获异常public static void try2() &#123; try (BufferedInputStream bin = new BufferedInputStream(new FileInputStream(new File("test.txt"))); BufferedOutputStream bout = new BufferedOutputStream(new FileOutputStream(new File("out.txt")));) &#123; // 执行完try中的语句过后,资源自动关闭 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 在上述的代码中，没有了finally操作，简化了程序员的操作。是一种优雅的编程方式。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两个有序数组的中位数]]></title>
    <url>%2F2019%2F04%2F30%2F%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例 1:nums1 = [1, 3]nums2 = [2]则中位数是 2.0 示例 2:nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5 思路在两个有序数组中找到中位数还没怎么想过，先回顾一下中位数的定义，一个有序数组，如果是奇数个，中位数是最中间那个数，如果是偶数个，中位数是中间两个数的平均数，拿到题的第一反应是组合成一个有序数组，但是时间复杂度告诉自己不允许这个做。那么还真的必须处理两个有序数组的中位数。为了方便，我们统一将中位数看成（m+n+1)/2和（m+n+2)/2的平均数，如果m+n是奇数，则（m+n+1)/2和（m+n+2)/2是同一个位置。 K是m+n的中间值，如何在两个有序数组中找到K元素呢?，使用i,j来标记两个数组的起始位置。边界条件如下： 某一个数组空白，直接取另一个数组的中位数 K=1，即当两个数组只有一个数字的时候，且取偶数个的左边较小的数字，即比较num1和num2的i，j位置上的数就可以了。 我们使用二分法对数组进行搜索，首先对K二分，分别在num1和num2中查找K/2个单元存在第K/2个数吗？如果存在，取出来，不存在就赋最大值 代码123456789101112131415161718public class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int m = nums1.length, n = nums2.length, left = (m + n + 1) / 2, right = (m + n + 2) / 2; return (findKth(nums1, 0, nums2, 0, left) + findKth(nums1, 0, nums2, 0, right)) / 2.0; &#125; int findKth(int[] nums1, int i, int[] nums2, int j, int k) &#123; if (i &gt;= nums1.length) return nums2[j + k - 1]; if (j &gt;= nums2.length) return nums1[i + k - 1]; if (k == 1) return Math.min(nums1[i], nums2[j]); int midVal1 = (i + k / 2 - 1 &lt; nums1.length) ? nums1[i + k / 2 - 1] : Integer.MAX_VALUE; int midVal2 = (j + k / 2 - 1 &lt; nums2.length) ? nums2[j + k / 2 - 1] : Integer.MAX_VALUE; if (midVal1 &lt; midVal2) &#123; return findKth(nums1, i + k / 2, nums2, j, k - k / 2); &#125; else &#123; return findKth(nums1, i, nums2, j + k / 2, k - k / 2); &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无重复字符的最长子串]]></title>
    <url>%2F2019%2F04%2F27%2F%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1:123输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2:123输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3:1234输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 思路这种字符串题目首先想到的思路是从左向右进行扫描，按照人脑的想法想法一步一步的向后扫，所以我们可以维持一个滑动窗口，每当出现一个重复的字母左界后移，没有就右界后移，每次循环的窗口都进行比较，取最大的数作为结果。 代码123456789101112131415161718192021222324class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; //定义结果 int result = 0; //滑动窗口的左右[i,j) int i=0,j=0; //定义一个Set，保证每个字母只出现一次 Set&lt;Character&gt; set = new HashSet&lt;&gt;(); //防止过界 while(i&lt;s.length() &amp;&amp; j&lt;s.length())&#123; //如果当前字符在set中不存在 if(!set.contains(s.charAt(j)))&#123; //将当前字符加入set并将右界后移 set.add(s.charAt(j++)); //取所有出现窗口的最大值 result = Math.max(result,j-i); &#125;else&#123; //如果出现重复的字符，将左界后移一位 set.remove(s.charAt(i++)); &#125; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两数相加]]></title>
    <url>%2F2019%2F04%2F27%2F%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[题目给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 思路这道题的思路非常简单，因为是链表而且低位是表头，所以直接按照加法的思路，从低位向高位进行进位就成。要对头结点进行操作时，为了避免两个输入链表同时为空，考虑创建哑节点dummy使用dummy-&gt;next表示真正的头节点。 代码123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; //新建哑元节点 ListNode dummy = new ListNode(-1); //从哑元节点后开始作为头结点,游标初始化处于头结点前 ListNode cur = dummy; //进位初始化为0 int carry = 0; //两条链都为零结束循环 while(l1 != null||l2 != null)&#123; //链1节点不为空时值给num1，为空时num1=0， num2同理 int num1 = l1 == null ? 0 : l1.val; int num2 = l2 == null ? 0 : l2.val; //将低位的进位和两个数相加 int sum = num1 + num2 + carry; //大于十则产生进位，carry=1,否则为0 carry = sum &gt;= 10 ? 1 : 0; //处理当前节点，值为个位尾数 cur.next = new ListNode(sum % 10); //游标后移 cur = cur.next; //如果l1不为空,l1后移，l2同理 if(l1 != null) l1 = l1.next; if(l2 != null) l2 = l2.next; &#125; //如果两条链都为零,并且有进位产生，新建一个高位进位节点就行 if (carry == 1) cur.next = new ListNode(1); //返回链，头结点是哑元节点后的节点 return dummy.next; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两数之和]]></title>
    <url>%2F2019%2F04%2F27%2FTwoSum%2F</url>
    <content type="text"><![CDATA[坚持就是胜利，开始刷题之旅 题目给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 12345给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 思路读懂这道题后的第一反应就是暴力向后搜索。但是这样的复杂度是O(n^2),肯定没有这么简单。只能通过空间来换时间，那么有什么查询方式是O(1)呢？第一反应是散列查找，也就是哈希查找。在java中。有HashMap类可以实现这个需求，那么代码可以是这个样子 代码解法一1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; //初始化一个int对应int的hashmap HashMap&lt;Integer, Integer&gt; m = new HashMap&lt;Integer, Integer&gt;(); //初始化结果数组 int[] res = new int[2]; //将题目给定的数组放入hashmap中 for (int i = 0; i &lt; nums.length; i++) &#123; m.put(nums[i], i); &#125; //开始搜索 for (int i = 0; i &lt; nums.length; i++) &#123; //搜索值等于和减去当前值 int t = target - nums[i]; //在hashmap中搜索并且保证存在而且不等于当前值 if (m.containsKey(t) &amp;&amp; m.get(t) != i) &#123; //对结果进行赋值，搜索到所以退出搜索 res[0] = i; res[1] = m.get(t); break; &#125; &#125; return res; &#125;&#125;; 提交上述代码，会发现内存消耗很大，时间也只是9ms超过了80%的人。一定有更优的解法。百度后发现可以将两个操作合二为一。上述解法先是将数组放入hashmap中，然后再进行查找。可不可以边放边找呢？先全部放入就是拿到前面的数去找后面的数。边放边找就是拿着后面的数去找前面的数。仔细想想，确实是这个道理。那么试试？？ 解法二123456789101112131415161718192021class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; //初始化一个int对应int的hashmap HashMap&lt;Integer, Integer&gt; m = new HashMap&lt;Integer, Integer&gt;(); //初始化结果数组 int[] res = new int[2]; //开始查找 for (int i = 0; i &lt; nums.length; i++) &#123; //如果hashmap中存在和减去当前数的数字 if(m.containsKey(target - nums[i]))&#123; //赋值，表示查找到，用后数找前数，所以需要换一下位置 res[1]=i; res[0]=m.get(target - nums[i]); break; &#125; //关键，每次循环都要放一个数到hashmap中，在查找中，拿着前数总是找不到后数的，因为还没有放进去，但是总会循环到后数，拿着后数的时候，前数已经放进去了，总是能找到的。所以这个方法很精妙，没有问题。 m.put(nums[i], i); &#125; return res; &#125;&#125; 上述方法快了1ms,内存消耗也少了。]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存区域]]></title>
    <url>%2F2019%2F04%2F23%2FJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[Java内存分布虽然对于入门的Java初学者来说是透明的，上课念PPT的老师也永远不会跟你提及这些概念，顶多在继承封装多态上让你背一些概念性的东西，但是都说知其然知其所以然，作为Java虚拟机知识体系基础的Java内存是如何进行管理的呢？理解了Java虚拟机的运行原理，对于排除代码BUG和程序性能优化有非常大的好处 程序计数器类似于CPU内部的PC寄存器，保存着字节码指令地址．程序需要通过程序计数器的值来选取下一条需要执行的字节码指令．程序的分支，跳转，循环，异常处理，线程恢复都得靠程序计数器来完成．程序计数器保证了JAVA各线程执行时的井然有序，所以是线程私有的，各个线程独立存储． 如果执行的是Java方法，程序计数器存储的是正在执行的字节码指令的地址 如果正在执行的是Native方法，程序计数器为空(Undefined) 此内存区域是唯一一个没有规定任何OutOfMemoryError情况的区域 Java虚拟机栈Java虚拟机栈同样是线程私有的，是方法执行时的结构．描述的是方法执行时的内存模型．每个方法执行时都会创建栈帧，用于存储方法的信息．方法的调用和返回过程，对应着栈帧的入栈和出栈过程 栈帧包含信息包括局部变量表，操作数栈，动态链接，和方法的返回地址 如果线程请求的栈深度超过了虚拟机允许的深度，会抛出StackOverflowError异常，如果允许动态扩展的栈在扩展时无法申请到足够的内存，会抛出OutOfMemoryError异常。 局部变量表简介局部变量表存放方法参数和方法内部局部变量。在编译成Class文件时，在方法的Code属性中的max_locals数据项中就确定了该方法局部变量表的最大容量，局部变量表以变量槽（Slot）为最小单位。详细内容会再进行专门介绍。 操作数栈简介操作数栈是一个后进先出的栈结构，最大深度在编译时写入Code属性中的max_stacks数据项中。方法开始执行时为空，方法内部的算术运算或者调用其他方法的时候就是通过操作数栈来进行参数传递的。与汇编语言中的CPU栈概念模型类似。 动态链接简介每个栈帧都包含指向运行时常量池中该栈帧所属方法的引用，Class文件的常量池中存在大量的符号引用，字节码中方法调用指令就以常量池中指向方法的符号引用作为参数。 在类加载阶段转化为直接引用，这种转化成为静态解析。 在每一次运行期间转化为直接引用，这部分成为动态链接。 方法返回地址简介方法一定是会执行完成的。有两种方式结束方法的执行。一是正常结束，调用者的PC计数器的值可以作为返回地址。二是异常退出，返回地址通过异常处理器表来完成。 方法退出等同于把当前栈帧出栈。可能执行的操作有，恢复上层方法的局部变量表和操作数栈，将返回值写入调用者栈帧的操作数栈，调整PC计数器的值指向方法调用指令的后一条。 本地方法栈本地方法栈与虚拟机栈发挥作用相似，其中执行的是虚拟机使用到的Native方法。各个虚拟机可能会不同，Sun HotSpot虚拟机就直接将本地方法栈和虚拟机栈合二为一。与虚拟机栈相同，本地方法栈也会抛出StackOverflowError和OutMemoryError异常。 Java堆Java堆是所有new对象的存储地，是Java虚拟机所管理内存中最大的一块。后续将要学习的内存回收算法就是与这块内存有关的。Java堆是所有线程共享的内存区域。Java虚拟机规范描述：所有的对象实例以及数组都要在堆上进行分配。 Java堆是GC管理的主要区域，可以细分为新生代，老年代。新生代是那种频繁被创建和销毁的对象的存放地，可能每次进行垃圾收集时就会有大批量的对象被清除。老年代的对象则存活率高，新生代的对象如果达到了老年代的标准，也会被划分到老年代，大对象创建时也会直接分配到老年代。具体细节会在GC回收中再总结。 方法区方法区和堆一样也是线程共享的区域。用于存储已经被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据，比如spring 使用IOC或者AOP创建bean时，或者使用cglib，反射的形式动态生成class信息等）。Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不进行垃圾搜集。这个区域的垃圾搜集行为比较少见。方法区不够大时，会抛出OutOfMemoryError异常。类信息如下，详细内容会在Java类加载机制中介绍。 类信息 类型全限定名。 类型的直接超类的全限定名（除非这个类型是java.lang.Object，它没有超类）。 类型是类类型还是接口类型。 类型的访问修饰符（public、abstract或final的某个子集）。 任何直接超接口的全限定名的有序列表。 类型的常量池。 字段信息。 方法信息。 除了常量意外的所有类（静态）变量。 一个到类ClassLoader的引用。 一个到Class类的引用。 运行时常量池Class文件中有一项信息存储编译期生成的各种字面量和符号引用，也就是常量池，这部分内容在类加载后会进入方法区的运行时常量池存放。运行时常量池具有动态性，并不要求运行时常量池严格和Class文件中的常量池内容一致，运行期间也能将新的常量放入池中，比如String类的intern()方法. 运行时常量池隶属于方法区，同样在内存不够大时抛出OutOfMemory异常。]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java虚拟机</tag>
      </tags>
  </entry>
</search>

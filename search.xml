<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设计模式——策略模式]]></title>
    <url>%2F2019%2F12%2F02%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[策略模式将算法作为一种策略传入对象，做到了算法和数据的分离，算法可以根据具体的需求进行无缝替换，和简单工厂模式实现的效果时一样的，但是实现的思想不同。 策略模式（Strategy）：它定义了算法家族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。 策略模式有如下的角色： Context上下文：属于配置类，通过这个类来控制具体使用哪一种策略。是高层使用者和底层策略之间的接口，封装了具体策略的内容。 Strategy类：抽象策略类，是对所有算法的抽象，抽象类和接口都可。 具体的策略类：在这些类中实现了具体的算法。 策略模式的UML类图如下： 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package StrategyPattern;abstract class Operation&#123; public abstract &lt;T extends Number&gt; double getResult(T paramA, T paramB);&#125;class Add extends Operation&#123; @Override public &lt;T extends Number&gt; double getResult(T paramA, T paramB)&#123; return paramA.doubleValue() + paramB.doubleValue(); &#125;&#125;class Sub extends Operation&#123; @Override public &lt;T extends Number&gt; double getResult(T paramA, T paramB)&#123; return paramA.doubleValue() - paramB.doubleValue(); &#125;&#125;class Mul extends Operation&#123; @Override public &lt;T extends Number&gt; double getResult(T paramA, T paramB)&#123; return paramA.doubleValue() * paramB.doubleValue(); &#125;&#125;class Div extends Operation&#123; @Override public &lt;T extends Number&gt; double getResult(T paramA, T paramB)&#123; return paramA.doubleValue() / paramB.doubleValue(); &#125;&#125;class Context&#123; private Operation operation; public Context()&#123; &#125; public void setStrategy(Operation operation)&#123; this.operation = operation; &#125; public &lt;T extends Number&gt; double executeStrategy(T paramA, T paramB)&#123; return operation.getResult(paramA, paramB); &#125;&#125;public class StrategyPattern &#123; public static void main(String args[])&#123; Context context = new Context(); context.setStrategy(new Add()); System.out.println("10+10="+context.executeStrategy(10,10)); context.setStrategy(new Sub()); System.out.println("11.5-10.2="+context.executeStrategy(11.5,10.2)); context.setStrategy(new Mul()); System.out.println("10*11="+context.executeStrategy(10L,11L)); context.setStrategy(new Div()); System.out.println("14/2="+context.executeStrategy(14,2)); &#125;&#125; 什么时候用策略模式呢？在上面的代码中我们看到加减乘除作为了一种策略传递给了策略上下文来进行配置。避免了大量的if-else和switch的出现。是一种常用的设计模式。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式——建造者模式，原型模式，单例模式]]></title>
    <url>%2F2019%2F11%2F23%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[本节总结的三个模式，是工厂模式后剩余的三个创建型模式，都是生产对象的模板代码，各有特色。 建造者模式建造者模式的思想是将一个复杂的对象的构建与他的表示分离，使得同样的构建过程可以表示创建不同的表示。工厂模式主要是生产相对简单的对象，它控制了一个个的流水线，产品通过这些预设的流水线来生产产品。而建造者模式更像是控制生产线上的一个个工人，负责决定生产什么样的产品，每一个工人负责一个模块，将实现和构建分离，根据不同的产品去替换生产线上的某个工人。最后可以实现复用一条生产线生产不同的产品。建造者模式的角色如下： Builder 抽象的建造者，不是必须的 ConcreateBuilder 具体的建造者 可以有多个「因为每个建造风格可能不一样」 Product 具体的产品「即被建造的对象」 Director 指挥者 统一指挥建造者去建造目标，导演不是必须的 建造者模式的UML类图如下：代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141/** * 抽象建造者 */abstract class Builder&#123; /** * 建造地基 */ abstract void buildGround(); /** * 砌墙 */ abstract void buildWall(); /** * 盖房顶 */ abstract void buildRoof(); /** * 得到最终的房子 */ abstract Product getRoom();&#125;/** * 产品 */class Product&#123; /** * 地面 */ private String ground; /** * 墙 */ private String wall; /** * 屋顶 */ private String roof; public String getGround() &#123; return ground; &#125; public void setGround(String ground) &#123; this.ground = ground; &#125; public String getWall() &#123; return wall; &#125; public void setWall(String wall) &#123; this.wall = wall; &#125; public String getRoof() &#123; return roof; &#125; public void setRoof(String roof) &#123; this.roof = roof; &#125; @Override public String toString()&#123; return "建造了"+ground+' '+wall+' '+roof+"的房子"; &#125;&#125;/** * 具体建造者 */class ConcreteBuilder extends Builder&#123; private Product product; public ConcreteBuilder()&#123; product = new Product(); &#125; @Override void buildGround()&#123; product.setGround("白色的地面"); &#125; @Override void buildWall()&#123; product.setWall("黄色的墙面"); &#125; @Override void buildRoof()&#123; product.setRoof("红色的屋顶"); &#125; @Override Product getRoom()&#123; return product; &#125;&#125;/** * 另一个具体的建造者 */class AnotherBuilder extends Builder&#123; private Product product; public AnotherBuilder()&#123; product = new Product(); &#125; @Override void buildGround()&#123; product.setGround("黑色的地面"); &#125; @Override void buildWall()&#123; product.setWall("绿色的墙面"); &#125; @Override void buildRoof()&#123; product.setRoof("白色的屋顶"); &#125; @Override Product getRoom()&#123; return product; &#125;&#125;/** * 指挥者，控制建造的过程 */class Director&#123; public Product create(Builder builder)&#123; builder.buildGround(); builder.buildRoof(); builder.buildWall(); return builder.getRoom(); &#125;&#125;public class BuilderPattern &#123; public static void main(String[] args)&#123; Director director = new Director(); Product roomA = director.create(new ConcreteBuilder()); System.out.println(roomA.toString()); Product roomB = director.create(new AnotherBuilder()); System.out.println(roomB.toString()); &#125;&#125; 原型模式当创建的对象有很多共用的属性时就可以使用原型模式，原型模式就好比孙悟空一根毫毛变出无数个小猴子，通过对象的复制免去了新建对象需要执行构造器的步骤，通过clone就可以得到一个新的对象。 原型模式的角色如下： 抽象原型类：声明克隆方法的接口，是所有原型类的公共父类，可以使接口，抽象类或者直接时一个具体的实现类。 具体原型类：实现了抽象原型类中声明的克隆方法，在克隆方法中返回自己的克隆对象。 客户类，客户类中通过对象实现的克隆方法创建对象，并根据客户端的具体要求个性化对象的属性。 原型模式的UML类图如下： 简单代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import java.io.*;/** * 具体原型类，Object类已经实现了clone接口 */class Room implements Serializable &#123; private String roof; private String wall; private String ground; public String getRoof() &#123; return roof; &#125; public void setRoof(String roof) &#123; this.roof = roof; &#125; public String getWall() &#123; return wall; &#125; public void setWall(String wall) &#123; this.wall = wall; &#125; public String getGround() &#123; return ground; &#125; public void setGround(String ground) &#123; this.ground = ground; &#125; @Override public String toString()&#123; return "建造了"+ground+' '+wall+' '+roof+"的房子@"+hashCode(); &#125; public Room clone() &#123; try &#123; ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); ObjectOutputStream outObject = new ObjectOutputStream(outputStream); outObject.writeObject(this); ByteArrayInputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray()); ObjectInputStream inObject = new ObjectInputStream(inputStream); return (Room) inObject.readObject(); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125;public class PrototypePattern &#123; public static void main(String[] args)&#123; Room room1 = new Room(); room1.setGround("白色地面"); room1.setRoof("白色的屋顶"); room1.setWall("红色的墙壁"); Room room2 = room1.clone(); room2.setWall("绿色的墙壁"); System.out.println(room1); System.out.println(room2); &#125;&#125; 单例模式单例模式算是最简单的一个设计模式了，如果一个类在系统运行过程中只需要一个对象的时候就可以使用单例模式了，单例模式在编码过程中有大量了应用。比如配置类对象，日志类对象，这些对象非常常用但是又毫无变化，那么就直接在系统中创建一个对象就行了，每次需要的时候也不用重新创建，拿来就用。 在java中单例模式是非常容易创建的，最简单的方式就是让构造器私有，并且只在内部实例化，给外部提供一个方法，每次通过这个方法就可以拿到这个对象，非常简单，类图就不画了，直接上代码，一看就懂。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Room&#123; /** * 私有构造函数，屏蔽掉默认的公有构造函数 */ private Room()&#123; &#125; private static Room instance = new Room(); private String ground; private String wall; private String roof; public String getGround() &#123; return ground; &#125; public void setGround(String ground) &#123; this.ground = ground; &#125; public String getWall() &#123; return wall; &#125; public void setWall(String wall) &#123; this.wall = wall; &#125; public String getRoof() &#123; return roof; &#125; public void setRoof(String roof) &#123; this.roof = roof; &#125; @Override public String toString()&#123; return "建造了"+ground+' '+wall+' '+roof+"的房子@"+hashCode(); &#125; public static Room getInstance()&#123; return instance; &#125;&#125;public class SinglePattern &#123; public static void main(String[] args)&#123; Room room = Room.getInstance(); room.setGround("绿色的地板"); room.setRoof("白色的屋顶"); room.setWall("白色的墙"); System.out.println(room); Room room2 = Room.getInstance(); room2.setWall("绿色的墙"); System.out.println(room2); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式——工厂模式]]></title>
    <url>%2F2019%2F11%2F21%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[不要过度设计，学习设计模式之前一定要牢记的一句话。过度设计并不是学习设计模式的初衷。我们使用设计模式就是为了能写出易维护，易扩展，易复用，灵活多样的应用，在合适的情况下使用合适的设计模式，才能达到理想的效果。23种设计模式只是模板代码，只有理解其中的思想，才能无招胜有招。现在我们先学习这些招式。从三工厂开始。 工厂模式，顾名思义，这就是个工厂，用来生产对象，直接在调用方New对象是不是耦合严重了呢？一但类名发生了变化，就要重新改代码了吗？工厂模式，解决了这个问题，通过第三方工厂去生产对象，符合依赖倒转原则。 简单工厂模式先说说什么叫简单工厂（Simple Factory），这就太简单了，如果你不想直接在调用方new一些对象，这些对象有一定的相似之处，那么就可以将他们封装起来，设置一个第三方工厂，直接在这个工厂类中根据调用方传递的参数生产相应的对象，这就是简单工厂。 简单工厂模式由三种角色组成。 工厂类：这个时本设计模式的核心角色，在简单工厂模式中含有一定的业务逻辑，根据逻辑的不同选择生成具体的产品。 抽象产品角色：它是所有产品的父类或者接口，具有所有产品共同的特性。 具体产品角色：工厂类生产的对象就是这些类的实例。 使用UML类图可以表示如下： 我们使用Java代码实现一下这个设计模式。加深映像。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114abstract class Operation &#123; private double numberA; private double numberB; public Operation(double numberA, double numberB) &#123; setNumberA(numberA); setNumberB(numberB); &#125; public double getNumberA() &#123; return numberA; &#125; public void setNumberA(double numberA) &#123; this.numberA = numberA; &#125; public double getNumberB() &#123; return numberB; &#125; public void setNumberB(double numberB) &#123; this.numberB = numberB; &#125; public abstract double getResult();&#125;class Add extends Operation &#123; public Add(double numberA, double numberB) &#123; super(numberA, numberB); &#125; @Override public double getResult() &#123; return super.getNumberA() + super.getNumberB(); &#125;&#125;class Sub extends Operation &#123; public Sub(double numberA, double numberB) &#123; super(numberA, numberB); &#125; @Override public double getResult() &#123; return super.getNumberA() - super.getNumberB(); &#125;&#125;class Mul extends Operation &#123; public Mul(double numberA, double numberB) &#123; super(numberA, numberB); &#125; @Override public double getResult() &#123; return super.getNumberA() * super.getNumberB(); &#125;&#125;class Div extends Operation &#123; public Div(double numberA, double numberB) &#123; super(numberA, numberB); &#125; @Override public double getResult() &#123; return super.getNumberA() / super.getNumberB(); &#125;&#125;enum OperationSign &#123; ADD, SUB, MUL, DIV;&#125;public class SimplyFactory &#123; public static Operation createOperate(double numberA, double numberB, OperationSign operate) &#123; Operation oper = null; switch (operate) &#123; case ADD: oper = new Add(numberA, numberB); break; case SUB: oper = new Sub(numberA, numberB); break; case MUL: oper = new Mul(numberA, numberB); break; case DIV: oper = new Div(numberA, numberB); break; &#125; return oper; &#125; public static void main(String args[])&#123; Operation addOper = SimplyFactory.createOperate(1.0,2.0,OperationSign.ADD); double addResult = addOper.getResult(); System.out.println(addResult); Operation subOper = SimplyFactory.createOperate(1.0,2.0,OperationSign.SUB); double subResult = subOper.getResult(); System.out.println(subResult); Operation mulOper = SimplyFactory.createOperate(1.0,2.0,OperationSign.MUL); double mulResult = mulOper.getResult(); System.out.println(mulResult); Operation divOper = SimplyFactory.createOperate(1.0,2.0,OperationSign.DIV); double divResult = divOper.getResult(); System.out.println(divResult); &#125;&#125; 工厂方法模式以上就是简单工厂的实现代码，但是回想我们学到的设计模式原则中的开闭原则，允许添加但是不允许修改，如果我想在加一个运算呢？是不是要修改createOperate方法。那么如何解决这个问题呢？那就再抽象一层，我们把原来在工厂类中直接生产具体对象的方式改成由方法类工厂去实现生产对象这个接口。这就是工厂方法模式。 工厂方法模式有以下成员组成： 工厂接口：定义了所有工厂具备的生产行为。 具体工厂类： 实现了工厂接口的生产方法，在这个类中生产具体的对象。 抽象产品角色：它是所有产品的父类或者接口，具有所有产品共同的特性。 具体产品角色：工厂类生产的对象就是这些类的实例。 使用UML类图可以如下表示： 使用代码的简单实现如下，该设计模式在简单工厂方法模式上再抽象了一层，很好的弥补了简单工厂方法模式违背的开闭原则，做到了增加工厂实现的时候不修改工厂的代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119package FactoryMethod;abstract class Operation&#123; private Double numberA; private Double numberB; public Operation(double numberA, double numberB)&#123; setNumberA(numberA); setNumberB(numberB); &#125; public Double getNumberA() &#123; return numberA; &#125; public void setNumberA(Double numberA) &#123; this.numberA = numberA; &#125; public Double getNumberB() &#123; return numberB; &#125; public void setNumberB(Double numberB) &#123; this.numberB = numberB; &#125; public abstract Double getResult();&#125;class AddOperation extends Operation &#123; public AddOperation(Double numberA, Double numberB)&#123; super(numberA,numberB); &#125; @Override public Double getResult() &#123; return super.getNumberA() + super.getNumberB(); &#125;&#125;class SubOperation extends Operation &#123; public SubOperation(Double numberA, Double numberB)&#123; super(numberA,numberB); &#125; @Override public Double getResult() &#123; return super.getNumberA() - super.getNumberB(); &#125;&#125;class MulOperation extends Operation &#123; public MulOperation(Double numberA, Double numberB)&#123; super(numberA,numberB); &#125; @Override public Double getResult() &#123; return super.getNumberA() * super.getNumberB(); &#125;&#125;class DivOperation extends Operation &#123; public DivOperation(Double numberA, Double numberB)&#123; super(numberA,numberB); &#125; @Override public Double getResult() &#123; return super.getNumberA() / super.getNumberB(); &#125;&#125;interface IFactory&#123; Operation CreateOperation(Double numberA, Double numberB);&#125;class AddFactory implements IFactory&#123; public Operation CreateOperation(Double numberA, Double numberB) &#123; return new AddOperation(numberA,numberB); &#125;&#125;class SubFactory implements IFactory&#123; public Operation CreateOperation(Double numberA, Double numberB) &#123; return new SubOperation(numberA,numberB); &#125;&#125;class MulFactory implements IFactory&#123; public Operation CreateOperation(Double numberA, Double numberB) &#123; return new MulOperation(numberA,numberB); &#125;&#125;class DivFactory implements IFactory&#123; public Operation CreateOperation(Double numberA, Double numberB) &#123; return new DivOperation(numberA,numberB); &#125;&#125;public class FactoryMethod &#123; public static void main(String args[])&#123; Double numberA = 10d; Double numberB = 20d; IFactory addFactory = new AddFactory(); Operation add = addFactory.CreateOperation(numberA,numberB); System.out.println(add.getResult()); IFactory subFactory = new SubFactory(); Operation sub = subFactory.CreateOperation(numberA,numberB); System.out.println(sub.getResult()); IFactory mulFactory = new MulFactory(); Operation mul = mulFactory.CreateOperation(numberA,numberB); System.out.println(mul.getResult()); IFactory divFactory = new DivFactory(); Operation div = divFactory.CreateOperation(numberA,numberB); System.out.println(div.getResult()); &#125;&#125; 抽象工厂模式既然在简单工厂的基础上单独抽象建造工厂可以构成工厂方法模式，那么生产的产品是否也是可以抽象的呢？所以就引出的本节的抽象工厂模式，如果生产的产品可以变化，那么是否可以直接抽象一个产品的接口出来呢？这个将具体的产品实现抽象的模式叫做抽象工厂模式。 角色如下： AbstractFactory：抽象工厂 ConcreteFactory：具体工厂 AbstractProduct：抽象产品 Product：具体产品 抽象工厂模式UML类图可以如下表示： 简单代码实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package AbstractFactory;abstract class Meat &#123; abstract String getMeat();&#125;class Beaf extends Meat &#123; private String name = "牛肉"; @Override public String getMeat() &#123; return this.name; &#125;&#125;class Fish extends Meat &#123; private String name = "鱼肉"; @Override public String getMeat() &#123; return this.name; &#125;&#125;abstract class Vegetables &#123; abstract String getVegetables();&#125;class Cabbage extends Vegetables &#123; private String name = "白菜"; @Override public String getVegetables() &#123; return this.name; &#125;&#125;class Tomato extends Vegetables &#123; private String name = "西红柿"; @Override public String getVegetables() &#123; return this.name; &#125;&#125;interface IEatFactory &#123; String eatMeat(); String eatVegetables();&#125;class Breakfast implements IEatFactory &#123; @Override public String eatMeat() &#123; Fish fish = new Fish(); return fish.getMeat(); &#125; @Override public String eatVegetables() &#123; Tomato tomato = new Tomato(); return tomato.getVegetables(); &#125;&#125;class Launch implements IEatFactory &#123; @Override public String eatMeat() &#123; Beaf beaf = new Beaf(); return beaf.getMeat(); &#125; @Override public String eatVegetables() &#123; Cabbage cabbage = new Cabbage(); return cabbage.getVegetables(); &#125;&#125;public class AbstactFactory &#123; public static void main(String args[]) &#123; IEatFactory launch = new Launch(); System.out.println("午餐吃的肉是：" + launch.eatMeat()); System.out.println("午餐吃的蔬菜是：" + launch.eatVegetables()); IEatFactory breakfash = new Breakfast(); System.out.println("早餐吃的肉是：" + breakfash.eatMeat()); System.out.println("早餐吃的蔬菜是：" + breakfash.eatVegetables()); &#125;&#125; 抽象工厂模式将产品抽象出来，客户端不需要知道具体的产品是如何生产的，不同的工厂生产不同的产品，比如数据库链接，底层是用Oracle还是Mysql实现不是客户端需要关心，底层也是可以随时替换的。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM常用虚拟机参数与分析]]></title>
    <url>%2F2019%2F10%2F19%2FJVM%E5%B8%B8%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%82%E6%95%B0%E4%B8%8E%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前段时间初步了解了JVM相关的书籍，读《深入理解JAVA虚拟机》。但是仅限与阅读，最近开始着手解决实际项目中的一些问题。 常用JVM参数设置我们在启动JAVA项目的时候时可以带启动参数的。无论是Tomcat，还是原生的JAVA项目。现在来总结一下常用的参数。 堆 -Xms 设置堆的最小空间大小，也是初始的大小 -Xmx 设置堆的最大空间大小，如果设置的与Xmx相同就是不会扩展堆内存 -Xmn 设置新生代的大小 -XX:NewSize 设置新生代初始大小 -XX:MaxNewSize 设置新生代的最大大小，和XX:NewSize合起来效果等于 -Xmn -XX:NewRatio 新生代和老年代大小的比值 -XX:SurvivorRatio 新生代中Eden区和Survivor区的大小比值，默认是4。也就是Eden:Survivor1:Survivor2 = 8:1:1 -XX:MaxTenuringThreshold 对象的年龄，即新生代的对象挺过多少次minor GC就可以进入老年代，默认是15。设置为0 就代表Survivor区没用了，存活对象直接进入老年代，所以一般会把这个值设置大一点，适合的对象使用适合的回收算法，只有活的够长，才有资格使用标记-整理算法。 -XX:PretenureSizeThreshold 还记得分配担保机制吗？如果对象比Survivor区还大，那么可以直接进入老年代，这个选项可以设置多大的内存可以直接进入老年代。 方法区方法区一般回收的效率很低，这里的内存是几乎不会回收的加载的类信息，常量，静态变量，即时编译器编译后的代码等数据，一般这些东西随程序启动而产生，随程序终止而消失，只有类的卸载才会清理方法区中的东西，但是类的卸载是十分不容易发生的，这在《深入理解JAVA虚拟机》中有介绍。Spring启动后在程序运行期间不会有太大的变动。 -XX:PermSize：方法区初始内存分配大小 -XX:MaxPermSize：方法区分配的内存的最大上限。 使用Linux命令进行JVM分析jstat命令首先通过ps 命令找到Java进程。 ps -ef | grep java 找到进程号PID后就可以使用jstat命令进行JVM状态的查看和分析。通过这个命令，我们能查看JVM在运行过程中的GC日志和实时的堆栈信息。参数很多，这里只是列举我常用的命令参数： -gcutil &lt;pid&gt; 统计GC情况。 -gc &lt;pid&gt; 统计GC堆目前的状态 -class(类加载器) &lt;pid&gt; 查看加载的类情况 jstat -gcutil &lt;pid&gt; :统计目前内存的使用情况以及GC情况 字段名称 字段意义 S0 第一个Survivor区域使用百分比 S1 第二个Survivor区域使用百分比 E Eden区使用百分比 O 老年代使用百分比 M 元空间（原永久代）使用百分比 CCS 类指针压缩空间的使用率 YGC 年轻代GC（Minor GC）的次数 YGCT 年轻代GC耗费的时间（单位为秒） FGC 全GC（FULL GC）的次数 FGCT 全GC所耗费的时间（单位为秒） GCT 全部GC所耗费的时间 YGCT+FGCT（单位为秒） jstat -gc &lt;pid&gt; :统计目前内存的使用情况以及GC情况 字段名称 字段意义 S0C 第一个Survivor区域容量（单位KB） S1C 第二个Survivor区域容量（单位KB） S0U 第一个Survivor区域已使用大小（单位KB） S1U 第二个Survivor区域已使用大小（单位KB） EC Eden区域容量（单位KB） EU Eden区域已使用容量（单位KB） OC 老年代容量（单位KB） OU 老年代已使用容量（单位KB） MC 元空间容量（单位KB） MU 元空间已使用容量（单位KB） CCSC 压缩类空间大小（单位KB） CCSU 压缩类空间使用大小（单位KB） YGC 年轻代回收次数 YGCT 年轻代GC耗费的时间（单位为秒） FGC 全GC（FULL GC）的次数 FGCT 全GC所耗费的时间（单位为秒） GCT 全部GC所耗费的时间 YGCT+FGCT（单位为秒） jstat -class &lt;pid&gt; :统计目前加载的类的情况 字段名称 字段意义 Loaded 装载的类的数量 Bytes 装载的类所占用的字节数 Unloaded 卸载的类数量 Bytes 卸载的类所占用的字节数 Time 装卸类所花费的时间 jinfo命令jinfo命令可以查看当前进程的虚拟机配置信息和系统变量。常用就一个参数 -flags。我们打出jinfo的命令信息 jinfo -flags &lt;pid&gt; 查看当前进程的虚拟机参数我们随便找一个Java进程具体看一下这个命令的结果是什么 上图我们看到的不正是本文开头讲的虚拟机参数么？堆的参数信息，一清二楚。通过这个命令，我们能快速的查看当前环境的JVM信息，有助于排查问题。]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8新特性——Stream流]]></title>
    <url>%2F2019%2F09%2F25%2FJava8%E6%96%B0%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94Stream%E6%B5%81%2F</url>
    <content type="text"><![CDATA[流是Java提供的一组操作集合的API，向流水线一样处理集合中的元素。元素流经过中间操作(intermediate operation)的处理，最后在终端操作(terminal operation)得到前面的处理结果。Stream流和Lambda表达式一样能够大大的提高开发效率。 流的简单使用承接上篇的Lambda表达式介绍。我们同样使用学生类来进行处理。 创建流有两种创建流的方法，我们经常会使用第一种。 调用集合的stream()方法或者parallelStream()方法创建流。 Stream类的静态of()方法创建流。 1234567List&lt;String&gt; createStream = new ArrayList&lt;&gt;();//顺序流Stream&lt;String&gt; stream = createStream.stream();//并行流Stream&lt;String&gt; parallelStream = createStream.parallelStream();//of()方法创建Stream&lt;String&gt; stringStream = Stream.of(createStream.toArray(new String[createStream.size()])); 流的分类流分为顺序流和并行流，并行流会使用多线程同时对集合中的多个元素进行处理，在使用并行流的时候要注意线程安全问题。 终端操作和中间操作终端操作会消费Stream流，并且产生一个结果，一旦被消费过了，就不被重用 中间操作会产生另外一个流，中间操作并不是立即发生的，在中间操作创建的新流执行完终端操作后，中间操作指定的操作才会发生，也就是延迟性。流的中间操作有无状态和有状态两种。 无状态表示元素之间互不影响，单独处理，和其他元素无关。 有状态表示元素之间是互相关联的，比如查找最小值最大值，排序，求和之类的操作。 常用流操作中间操作 distinct()，去重操作，将Stream流中的元素去重后，返回一个新的流。 filter(Predicate predicate)：筛选符合条件的元素后重新生成一个流。 map(Function mapper)：产生一个新流，对调用的流中的元素应用mapper，新流中包含这些元素，一般用作转换，或者单独抽出某个字段组成一个新的流。 sorted(Comparator) 将流按照Comparator排序。 peek(func) 把每个元素传入fun执行，执行后的元素组成一个新流。 终端操作 void forEach（Consumer action)：遍历流中的元素。（终端操作） Optional min(Comparator comparator)和Optional max(Comparator comparator)：获取流中的最大最小值，比较器可以自己定义。（终端操作） findFirst() 返回第一个元素。 findAny() 返回任意元素。用作随机元素提取。 anyMatch(Predicate) 任意元素匹配时返回true allMatch(Predicate) 所有元素匹配时返回true noneMatch(Predicate) 没有元素匹配时返回true reduce(func) 从流中计算某个值，接受一个二元函数作为累计器，从前两个元素开始持续应用它，累积器的中间结果作为第一个参数，流元素作为第二个参数。 reduce(a,fun) a为幺元值，作为累计器的起点 reduce(a,func1,func2) 与二元变形类似，并发操作中，当累积器的第一个参数与第二个参数都为流元素类型时，可以对各个中间结果也应用累积器进行合并，但是当累积器的第一个参数不是流元素类型而是类型T的时候，各个中间结果也为类型T，需要fun2来将各个中间结果进行合并 搜集器常用的搜集器如下： collect(Collector) iterator() 迭代器 forEach(fun) 遍历 toArray() 返回基本类型数组 Collectors.toList() 搜集流组成一个List Collectors.toSet() 搜集流组成一个Set Collectors.toMap(fun1,fun2) 搜集流组成一个Map,fun1是键，fun2是值 流使用例子使用上节我们使用的学生类进行举例1.按照成绩从小到大排序 1234List&lt;Student&gt; sort = students.stream() .sorted(Comparator.comparing(Student::getScore) .reversed()) .collect(Collectors.toList()); 2.取出所有成绩不及格的学生 123List&lt;Student&gt; filter = students.stream() .filter(student -&gt; student.getScore() &lt; 60) .collect(Collectors.toList()); 3.取出所有学生的名字 123List&lt;String&gt; map = students.stream() .map(Student::getName) .collect(Collectors.toList()); 4.取出前三个学生 12List&lt;Student&gt; limit = students.stream().limit(3) .collect(Collectors.toList()); 5.取出成绩最好的人 123Student max = students.stream().max( Comparator.comparing(Student::getScore)).get(); 6.有没有人考100分 123boolean anyMatch = students.stream().anyMatch( student -&gt; student.getScore().equals(100)); 7.统计及格的有多少人 123long count = students.stream().filter(str -&gt; student.getScore() &gt;= 60).count(); 8.对于不及格的学生，我们把它的成绩改成60 12345List&lt;Student&gt; peek = students.stream().peek(student -&gt;&#123; if(student.getScore() &lt; 60)&#123; student.setScore(60); &#125;&#125;).collect(Collectors.toList());]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8新特性——lambda表达式]]></title>
    <url>%2F2019%2F09%2F22%2FJava8%E6%96%B0%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[最近接触到lambda表达式，实在是太方便了，就在此总结一下。lambda表达式由三个部分组成。第一部分为一个括号内用逗号分隔的形式参数，参数是函数式接口里面方法的参数；第二部分为一个箭头符号：-&gt;；第三部分为方法体，可以是表达式和代码块，如果是代码块的话，需要使用{}将语句括起来。语法如下 12(paramterts) -&gt; expression;(int a, int b) -&gt; &#123;return a+b&#125;; 一个标准的例子如下： 12345678910// 匿名内部类Runnable r1 = new Runnable()&#123; @Override public void run()&#123; System.out.prinln("Hello world!"); &#125;&#125;//Lambda 表达式Runnable r1 = () -&gt; System.out.println("Hello world!"); 在上述的例子中，我们发现了Lambda表达式的好处，简洁，减少了很多的模板代码，同样的语义，Lambda表达式只需要关心具体的实现就可以了。 lambda表达式的本质lambda表达式本质是一个匿名函数。对于Java世界里一切都是对象来说有些另类，但是确实是Lambda表达式为Java引入了函数式编程的思想，虽然在具体实现中，Lambda表达式依附于一种特别的对象——函数式接口。Lambda表达式即没有声明的方法，也没有访问修饰符，返回值声明和名字。 函数式接口函数式接口就是只包含一个抽象方法的接口。Lambda表达式的本质就是实现一个函数式接口。传统的函数式接口实现可以如下表示： 1234567891011@FunctionalInterfaceinterface MylambdaInterface&#123; void doSomething(String s);&#125;public class MyInterfaceImpl implements MylambdaInterface&#123; @Override public void doSomething(String s)&#123; System.out.println(s); &#125;&#125; Lambda表达式实现如下： 1MyLambdaInterface test = (s) -&gt; System.out.println(s); Lambda表示式只能实现一个方法，所以他的目标类型只能是函数式接口 Lambda表达式可以直接将一段代码赋值给一个变量，这段代码，也就是箭头的右边就是接口的实现，左边就是接口的参数。等号左边就是函数的返回值。简洁清晰。 结合Stream的操作Lambda对于集合的操作是非常普遍的，它对于并行操作支持很好，能够大大简化代码的行数，缺点是省略的地方没写过Lambda表达式的人可能看不懂。举一些例子来看Lambda表达式操作集合的便携性，我们先看看什么是Stream。 Java8中的Stream是对集合(Collection)对象功能的增强，它专注于对集合对象进行各种非常便利，高效的聚合操作。而且Lambda表达式和Stream天然的支持并行程序，他们合作起来能够大大的提高程序的可维护性。Stream(流)更像是一个升级版本的迭代器。单向不可往复，像流水一样一去不复返。但是Stream可以作并行操作。展示几个常用的操作。 以学生类为例，学生有两个字段，name和score。 1.将所有不及格的学生单独抽一个List出来。 123public void notPassStudent(List&lt;Student&gt; students)&#123; List&lt;Student&gt; filterStudent = students.stream().filter(one -&gt; one.getScore() &lt; 60).collect(Collectors.toList());&#125; 而传统的方式是怎么做的呢？ 12345678public void notPassStudent(List&lt;Student&gt; students)&#123; List&lt;Student&gt; filterStudent = new ArrayList&lt;&gt;(); for(Student student: students)&#123; if(student.getScore() &lt; 60)&#123; filterStudent.add(student); &#125; &#125;&#125; 高下立判，用Lambda和Stream更加的简洁常用filter进行筛选的动作，后面将具体的学习Stream流的操作。现在我们只讨论使用场景。]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垃圾搜集（三）——常用垃圾搜集器过程整理]]></title>
    <url>%2F2019%2F09%2F01%2F%E5%9E%83%E5%9C%BE%E6%90%9C%E9%9B%86%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E5%9E%83%E5%9C%BE%E6%90%9C%E9%9B%86%E5%99%A8%E8%BF%87%E7%A8%8B%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[上节总结了垃圾搜集算法，总觉得看书要能自己给自己讲一遍才能理解的透彻。那么具体在虚拟机中的垃圾搜集器是如何做的呢？具体步骤是什么？回忆第一节的内容，我们首先需要判定对象可以回收吗？然后再使用垃圾回收算法对堆中的内存进行整理。 对象的标记在第一节中总结了如何判定对象已死。目前虚拟机中都是使用的可达性分析算法。需要从GC Roots节点进行搜索，找到引用链。但是有个问题是，你在进行可达性分析的时候程序还是在运行着的，那么在分析过程中对象的引用关系还是在不停的变化着的，这样的话就不满足准确性和一致性。为了保证一致性，必须在逐个检查引用的时候停顿所有的Java执行线程。这个停顿叫做“Stop The World”。无论在那种垃圾搜集器中，这个过程是无法被避免的。 但是当线程停下来的时候虚拟机并不会一个不漏的检查所有的执行上下文和全局的引用位置，在HotSpot虚拟机中使用一组成为OopMap的数据结构，在类加载完成后，HotSpot就会把对象内偏移量上是什么类型的数据计算出来，这样在GC扫描的时候可以直接得知那些地方是引用类型。 安全点停顿线程并不是所有的地方都可以停顿，只有到达了安全点才能够进行停顿。但是是如何进行安全点的选择？安全点选定太少，GC等待时间就太长，选的太多，GC就过于频繁。选定原则是”具有让程序长时间执行的特征“，也就是在这个时刻现有的指令是可以复用的。一般选在方法调用、循环跳转、抛出异常的位置。 如何让线程在安全点停止呢？有两种方式。抢先式中断、主动式中断。 抢先式中断：GC发生时，中断所有线程，如果发现有线程不再安全点上，就恢复线程让它运行到安全点上。现在几乎不用这种方案。 主动式中断：设置一个标志，和安全点重合，再加上创建对象分配内存的地方。各个线程主动轮询这个标志，发现中断标志为真就挂起自己。HotSpot使用主动式中断。]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单理解Spring中的DI]]></title>
    <url>%2F2019%2F09%2F01%2F%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3Spring%E4%B8%AD%E7%9A%84DI%2F</url>
    <content type="text"><![CDATA[无论我们学的设计模式，还是要遵守的编码规范，都在强调一件事情，如何高效的进行开发。设计模式的宗旨是什么？设计出易维护，易扩展，易复用，灵活多样的应用。编码规范做了什么？设计一套科学的接口，大家都来依照这个接口的做法进行开发，高效的与他人进行合作。千奇百怪的编码风格自然会增加大家在评审代码的时候的难度。那么作为Java程序员必须学习的Spring究竟做了什么呢？我们一直在追求的一件事情就是代码的低耦合和高内聚。而Spring帮我们做了这件事情，大大的简化了Java开发。Spring时如何降低开发的复杂性的？ 基于POJO的轻量级和最小入侵性编程； 通过依赖注入和面向接口编程实现松耦合； 基于切面和惯例进行声明式编程； 通过切面和模板减少样板代码； 面试的时候都会问一个问题，什么是IOC，什么是AOP。这只是Spring的其中两个概念而已，我们具体学习Spring，是要看他到底是如何简化Java开发的。这里有两个名词： 依赖注入 组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中 控制反转 依赖双方都不互相控制，将对象的控制权交给第三方Spring来进行管理 实际来讲，并没有什么区别，即控制反转是由依赖注入来实现的。 依赖注入我们在刚开始学习Java的时候，如何操作对象之间的依赖关系呢？如果A依赖于B，那么在A中new一个B的对象就好了。但是这样有一个问题，耦合度太高了。new的时候需要指明包的名称，如果依赖的对象突然有变化，那就需要重新改，那就太麻烦了。如果此时有个第三方机构将这种依赖进行统一的管理，此时调用的一方就不用管被调用方的位置，只需用知道对方的名字和模样拿来直接用就行，具体这个类的位置，交给Spring来管理。 通常Spring 通过 @Autowired注解实现自动装配 依赖注入有三种方式，分别是构造器注入，接口注入和方法参数注入。来看他们的实现方式和区别。 接口注入通过将@Autowired注解放到需要注入的字段上面，这种注入方式使用的最多 12345678910@Servicepublic class UseFunctionService &#123; @Autowired FunctionService functionService; public String SayHello(String word)&#123; return functionService.sayHello(word); &#125;&#125; 优点：简洁明了，基本不改变代码 set方法注入通过将@Autowired注解放到set方法上 123456789101112131415161718@Servicepublic class UseFunctionService &#123; FunctionService functionService; @Autowired public void setFunctionService(FunctionService functionService) &#123; this.functionService = functionService; &#125; public FunctionService getFunctionService() &#123; return functionService; &#125; public String SayHello(String word)&#123; return functionService.sayHello(word); &#125;&#125; 不常见，特殊情况下需要在类加载后重新注入的话可以使用这个方式 构造器注入通过将 @Autowired注解放到构造器上方完成注入 1234567891011121314@Servicepublic class UseFunctionService &#123; FunctionService functionService; @Autowired public UseFunctionService(FunctionService functionService)&#123; this.functionService= functionService; &#125; public String SayHello(String word)&#123; return functionService.sayHello(word); &#125;&#125; 推荐使用构造器注入，优点如下： 依赖不可变 依赖不为空，当依赖的参数为空的时候启动会报错，解决忘记配置XML的疏忽，我就犯过一次错误，运行时报空指针错误半天没反应过来，后来单步调试才发现是依赖的对象为空，XML中忘记配置Bean了，这种情况的话使用构造器注入会在启动时报错。 完全初始化状态，在调用依赖时保证了依赖也是初始化完成的状态。 注册依赖注入是对所有的JavaBean进行操作，但是如何才能让Spring检测到你写的类呢？这就是bean的注册问题了。Spring是一个工厂，我们要将类放进这个工厂，才能委托Spring进行对象生命周期的管理。Spring 传统的方式是用XML进行bean的管理，这样的好处是进行了统一的管理。但是颇为麻烦，每次新加入一个服务还需要修改XML文件。这里推荐使用Springboot推荐的包自动扫描方式。 如何声明bean如何让你写的类被Spring容器找到，Springboot中一般有四种Bean的声明注解分别是： @Component 组件，没有明确的角色 @Service 在业务逻辑层使用，一般注册为一个服务 @Repository 在数据库访问层（dao）层使用,一般注册为数据库操作 @Controller 在展示层中使用，一般注册为对外的接口。 Spring如何检测到这些BeanSpringboot一般使用自动扫描的方式。具体在配置类中使用 Diconfig.java 123456789package com.sujunhao.Main;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan("com.sujunhao")public class DiConfig &#123;&#125; 使用@Configuration表示这是一个配置类使用@ComponentScan设置bean需要扫描的包 Main.java 123456789101112131415package com.sujunhao.Main;import com.sujunhao.Service.UseFunctionService;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class Main &#123; public static void main(String[] args)&#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(DiConfig.class); UseFunctionService useFunctionService = context.getBean(UseFunctionService.class); System.out.println(useFunctionService.SayHello("helloword")); context.close(); &#125;&#125; 在Main中使用AnnotationConfigApplicationContext作为Spring容器，加载Spring应用上下文，使用配置类作为初始化的参数，避免使用application.xml进行配置，这是一种相当简介的办法。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垃圾搜集（二）——常用垃圾回收算法]]></title>
    <url>%2F2019%2F08%2F25%2F%E5%9E%83%E5%9C%BE%E6%90%9C%E9%9B%86%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[标记-清除算法算法分为两个部分：标记和清除。首先标记出需要回收的对象，然后统一的回收。 问题如下： 效率太低，标记和清除两个步骤的效率都不高。 该算法完成后会产生大量的内存不连续碎片，碎片太多会导致后来再进行分配大对象时无法得到足够的内存而不得不再触发一次垃圾搜集动作。 复制算法 复制算法解决了效率的问题，复制算法的思想是将内存区域分成两块，每次只使用其中的一块，当这一块的内存使用完了的时候就将标记存活的对象复制到另一块内存中去。然后统一清除这一块使用的内存。这种方法高效且简单，根本不用考虑内存碎片的情况，但是代价时将使用的内存缩小到了原来的一半。 但是新生代中的对象都有一个特性就是朝生夕死，所以基本每次回收都能够回收绝大部分的内存。商用虚拟机中的新生代回收算法并不是按照1:1来进行划分的。它将新生代分为较大的Eden区和两块较小的Survivor区，每次使用Eden和其中的一块Survivor。每次回收使用中的内存，统一复制到未使用的Survivor中。然后将Eden和Survivor清空。HotSpot虚拟机的比例是8:1。当Survivor不够用的时候，会直接通过分配担保机制进入老年代。如何分配担保请点击这里。 问题如下： 会浪费掉一定的内存，但是现在内存足够大，浪费掉的不值一提。 如果回收过后的内存大于Survivor的空间，会放不下，但是解决办法是使用分配担保机制将内存直接放入老年代。 标记-整理算法标记整理算法适合那种对象存活率较高的内存区域，比如老年代，如果老年代依然使用复制算法的话，效率太低。且老年代的内存比较稳定且大，如果使用复制算法，会导致出现所有对象都存活的极端情况，导致效率又低时间又慢。所以老年代一般使用的就是标记整理算法。 标记整理，顾名思义就是先标记，再整理。首先让所有标记存活的对象那个向一端移动，然后直接清理掉头指针以外的区域就行了，相当于整理的动作。 总结每个Java对象的生命周期是不一样的。新生代都是朝生夕死的对象，老年代的对象一般也是长期存活的。当新生代的Survivor区某个对象存活一定的次数后就可以将它移动到老年代。且不同的区域应该使用不同的算法，新生代使用复制算法，效率高又快，老年代使用标记整理算法，这就是分代搜集的思想。]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垃圾搜集（一）——如何判定对象已死]]></title>
    <url>%2F2019%2F08%2F25%2F%E5%9E%83%E5%9C%BE%E6%90%9C%E9%9B%86%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%A6%82%E4%BD%95%E5%88%A4%E5%AE%9A%E5%AF%B9%E8%B1%A1%E5%B7%B2%E6%AD%BB%2F</url>
    <content type="text"><![CDATA[垃圾回收是Java的一大特色，这个特性让程序员可以不用像C++一样思考在哪里写delete语句来释放new出来的内存。就算是这样，我们也得学习Java虚拟机到底是如何做到的，不至于在程序出问题时拿着GC日志看不懂。本文总结三个问题。 那些内存需要回收？ 什么时候回收？ 如何回收？ 我们首先来回忆Java运行时数据区的各个部分，虚拟机栈，程序计数器，本地方法栈（和虚拟机栈合并）三个区域是线程私有的，随线程生而开辟，随线程灭而消亡。虚拟机栈在线程执行时，方法不停的出栈入栈，每一个栈帧分配多少内存已经由类结构确定了，方法出栈的时候这部分内存自然就释放了。反应到代码就是方法内局部变量（不是对象），那些内存区域直接开辟在栈帧里面的变量。所以，需要回收的内存区域就是堆和方法区这些线程共享的区域。在进行垃圾搜集时，垃圾搜集器就是对堆和方法区进行操作。在HotSpot虚拟机中，方法区也叫作永久代，和堆没关系。堆=新生代+老年代。而垃圾搜集是发生在新生代，老年代和永久代之中的行为。以下是Java堆结构图 Java线程共享的区域中，Java堆分为新生代和老年代，其中新生代分为Eden区（存放新生对象），两个幸存区（From Survivor和To Survivor）（存放每次垃圾回收后存活的对象）。为什么这么设置呢？复制算法中会讲到。 如何判定对象是否需要回收引用计数法垃圾搜集器在对堆做回收动作之前，总得知道那些对象是可以回收的，那些则不能回收。最简单的方法是引用计数法（Reference Counting）具体做法就是给对象添加一个引用计数器，每当有一个地方引用它时，就给这个引用计数器加1；当引用失效时，计数器就减1。如果计数器为0了，就表示这个对象已经不再使用了。方法简单，但是有一个缺点是不能解决循环引用，如果两个对象互相引用的话，他们的计数器就永远不能为0。 可达性分析算法（Reachability Analysis）主流的GC搜集器的基本思路就是可达性分析，基本思路如下：通过一系列的“GC Roots”的对象作为起始点，从这些节点向下搜索，会产生一个图型结构，或者是树型结构。如果一个对象不在任何的引用链中，则表示对象已经不再使用。 Java中常用的GC Roots对象如下： 虚拟机栈（栈帧中的本地变量表）中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI（Native方法）引用的对象 方法区回收由于方法区存储着类的信息，类的回收一般性价比很低，在新生代中，有很多对象都是朝生夕死，一次回收会有70%~95%的空间。永久代的效率则非常低。在方法区中主要回收两部分内容。废弃的常量和无用的类，常量池的回收非常简单，如果当前系统没有对象引用常量池中的内容，那么这个常量就是可以回收的状态。 废弃的类的要求就比较严格。 该类的所有实例都已经被回收，Java堆中不存在该类的任何实例 加载该类的ClassLoader已经被回收 该类对应的java.lang.Class对象没有在任何地方被引用，无法通过反射访问类的方法。]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式几大原则]]></title>
    <url>%2F2019%2F08%2F24%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%87%A0%E5%A4%A7%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[六大原则 单一职责原则 里氏替换原则 依赖倒转原则 开放-封闭原则 接口隔离原则 迪米特法则 设计模式的目标 易维护，易扩展，易复用，灵活多样。 单一职责原则 单一职责原则，就一个类而言，应该仅有一个引起它变化的原因。 如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭到意想不到的破坏。 软件设计真正要做的很多内容，就是发现职责并把那些职责相互分离，如何判断是否应该分离出类来，如果你能够想到多于一个的动机去改变一个类，那么这个类就具有了多于一个的职责。此时就应该考虑职责的分离。 依赖倒转原则 依赖倒转原则A. 高层模块不应该依赖低层模块。两个都应该依赖抽象。B. 抽象不应该依赖细节。细节应该依赖抽象。 说白了，依赖倒转原则就是要针对接口编程，不要针对实现编程。最好每个类都要有接口，或者抽象类。面对接口编程能够减少类之间的耦合度。高层模块不应该依赖低层模块，两个都应该依赖抽象。 里氏替换原则 里氏替换原则：子类型必须能够替换掉他们的父类型。 在一个软件实体中如果使用的是父类的话，那么一定适用于其子类，而且察觉不到父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化。 只有当子类可以替换掉父类时，软件单位的功能不受到影响时，父类才能真正的被复用，而子类也能够在父类的基础上增加新的行为，子类最好不要重写父类的方法，而是增加父类的行为。正式由于子类型的可替换星才使得父类类型的模块在无需修改的情况下就可以扩展。 开放-封闭原则 开放-封闭原则，软件实体（类，模块，函数等等）应该可以扩展，但是不可修改。 对于扩展是开放的，对于修改是封闭的。对于需求一直变化的系统，我们都不要去修改原有的逻辑，而是增加新的逻辑。对于新需求一来就要把整个程序推到重来时不可取也是不现实的，所以开闭原则告诉我们，在程序设计的时候要时刻考虑，尽量让这个类足够好，写好了就不要去修改，如果有新的需求，增加一些类就完事了，原来的代码能不动就不动。 开放封闭原则时面向对象设计的核心所在，遵循这个原则可以带来面向对象技术所称的巨大好处 可维护，可复用，可扩展，灵活性好 开发人员应该仅对程序中呈现出频繁变化的哪些部分做出抽象，然而，对于应用程序中的每个部分都刻意地进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。 接口隔离原则 接口隔离原则A.客户端不应该依赖它不需要的接口B.类间的依赖关系应该建立在最小的接口上 不要在一个接口里面放很多的方法，这样会显得这个类很臃肿不堪。接口应该尽量细化，一个接口对应一个功能模块，同时接口里面的方法应该尽可能的少，使接口更加轻便灵活。或许看到接口隔离原则这样的定义很多人会觉得和单一职责原则很像，但是这两个原则还是有着很鲜明的区别。接口隔离原则和单一职责原则的审视角度是不同的，单一职责原则要求类和接口职责单一，注重的是职责，是业务逻辑上的划分，而接口隔离原则要求方法要尽可能的少，是在接口设计上的考虑。 迪米特法则 迪米特法则，如果两个类不必彼此直接通信，那么这个两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。 首先在累的结构设计上，每一个类都应当尽量降低成员的访问权限。 类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几大基础排序算法复习]]></title>
    <url>%2F2019%2F08%2F17%2F%E5%87%A0%E5%A4%A7%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[大学也毕业了，呆了一段时间公司，干的活多是琐碎的工作，提高了项目能力，但是对于编程基础的东西绝对不能丢，就像项目组最近在排查性能问题一样，如果程序员的基础扎实了，很难会出现性能的问题，节省时间和空间几乎成了本能的行为，又怎么会出现项目迭代过程中专门花时间进行性能瓶颈的排查呢？项目几经易手，原来的代码难改，逻辑混乱，对于业务不太熟悉的人来说，代码根本无从下手。所以就像破窗户一样只会越来越大。 不要容忍破窗户 出自《程序员修炼之——从小工到专家》 所以我准备系统的复习大学期间的算法知识。先从常用的排序和查找开始。 冒泡排序冒泡排序是大学中学习C++后接触到的的第一个算法，算法思想是每次比较相邻的两个数，大的向后排，不停的后移，每经过一轮，就会有一个大数冒到最后去，俗称冒泡法。这是个稳定的排序算法，无论数据如何排列，程序经过的步骤是一样的。不会因为数据的排列不同而少做处理。 算法实现123456789101112131415161718192021222324//冒泡排序void bubble_sort(int *array,int length)&#123; if(array == NULL)&#123; return; &#125; int flag=1; //flag的作用是记录上一轮是否发生了交换， //如果没有，那就说明已经排好了序，直接退出 for (int i = 0; i &lt; length - 1&amp;&amp;flag; i++) &#123; flag=0; for (int j = 0; j &lt; length - i - 1; j++) &#123; if (array[j] &gt; array[j+1]) &#123; int temp = array[j]; array[j] = array[j+1]; array[j+1] = temp; flag=1; &#125; &#125; &#125;&#125; 思路整理原始的冒泡排序是这样的，两层循环，外层执行一次表示一轮，每执行一次都代表了一个大数已经冒出去了，内层循环表示相邻两个数之间的比较，并且比较的指针位置随着循环的执行在不停地向后移动。循环中if判断表示两个数之间交换位置。上述方法和课本学习的原始冒泡排序不太一样，他加入了一个标志位flag，这个标志位记录了本轮有没有进行过数字位置的变动，如果进行到某一轮，每一个数的位置都没有发生变化，那么就代表所有的数字都已经到了他该放置的位置。所以排序就结束了，直接退出循环。 最佳情况：O(n) 最差情况：O(n^2) 平均时间复杂度：O(n^2) 空间复杂度为O(1) 稳定排序算法 插入排序插入排序使用了和冒泡不一样的思想，他的思路不是冒泡那种根据频繁变动位置来处理，而是在一轮中拿出一个基准值来进行判断。他的思路是这样的，默认第一轮最左边的数是最小的，所以第一轮不进行，直接拿左数第二个数作为第一个基准值。并对已经排序的数组中从右向左比较，如果比这个数大，向后挪一个位置，相当于占用了刚刚基准值的位置，直到找到一个位置上的数比基准值小，那么基准值就插入到这个数的后面，如果比这个基准值小，那么前面的所有数都比这个基准值小，本轮结束。直到所有的数都作为基准值进行过一侧比较，整个算法结束。 算法实现123456789101112131415161718//插入排序void insert_sort(int *array,int length)&#123; if(array == NULL)&#123; return; &#125; for(int i=1;i&lt;length;i++) &#123; int j=i-1; int temp=array[i]; while(array[j]&gt;temp&amp;&amp;j&gt;=0) &#123; array[j+1]=array[j]; j--; &#125; array[j+1]=temp; &#125;&#125; 算法分析 最佳情况：O(n) 最坏情况：O(n^2) 平均时间复杂度：O(n^2) 空间复杂度：O(1) 稳定排序算法 快速排序快速排序是一个对冒泡排序的一大改进，冒泡排序采用的是挨个比较的办法，快速排序的思想则是分治法，取出一个数，将所有比这个数小的放在左边，比这个数大的放在右边。这样会产生两个子数组，然后在这两个子数组中分别再采用相同的策略，直到不能再分，这样处理的步骤会比冒泡排序少很多。采用的是分治递归的思想。 那么如何处理基准值比较这个逻辑呢？常用的是挖坑法。取出头部第一个数，设置头尾两个指针，先从尾部开始向前移动尾指针，出现第一个比基准数小的数就放置在基准数留下的坑中，此时该数的原始位置就成了一个新的坑位。然后再从头部向后移动头部指针，将第一个大于基准数的数向后挪，放置在刚刚新的坑位上。这样交替移动头尾指针，直到最后头尾指针相遇，此时最后一个坑位就是相遇的地方，将基准数填到这个位置，一轮排序就结束了。 然后使用相同的策略对基准数左右的两个子数组进行排序，同样是调用一轮排序的算法。只不过把左子数组的尾指针换成第一轮的基准数左边的位置，把右子数组的头指针换成了基准数右边的位置而已。直到递归的把所有的数全部排完。 算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//快速排序int quick_sort(int *array,int _left,int _right)&#123; //挖坑法 if(_left&lt;_right)&#123; int left=_left;//左指针 int right=_right;//右指针 int key=array[_left];//将数组第一个数作为基准值 while(left&lt;right)&#123; while(right&gt;left&amp;&amp;key&lt;=array[right])&#123; //从右向左找到第一个小于基准值的值 right--; &#125; array[left]=array[right]; //将右指针的值赋给左指针，第一次会覆盖基准值 while(right&gt;left&amp;&amp;key&gt;=array[left])&#123; //从左向右找到第一个大于基准值的值 left++; &#125; array[right]=array[left]; //将左指针的值赋给右指针，会覆盖掉刚刚右指针多出来的旧位置 &#125; array[left]=key;//最后左右指针归于中间一处，此处放回基准值 return left; &#125;&#125;//快速排序递归实现void quick_sort_recursion(int *array,int left,int right)&#123; if(left&gt;right) return; int index = quick_sort(array,left,right); quick_sort_recursion(array,left,index-1); quick_sort_recursion(array,index+1,right);&#125;//快速排序非递归实现void quick_sort_Not_recursion(int *array,int left,int right)&#123; if(left&gt;=right) return; stack&lt;int&gt; s;//辅助栈，代替调用栈，防止调用栈溢出 s.push(left); s.push(right);//后入的right，所以要先拿right while(!s.empty())//栈不为空 &#123; int right = s.top(); s.pop(); int left = s.top(); s.pop(); int index = quick_sort(array,left,right); if((index - 1) &gt; left)//左子序列 &#123; s.push(left); s.push(index - 1); &#125; if((index + 1) &lt; right)//右子序列 &#123; s.push(index + 1); s.push(right); &#125; &#125;&#125; 算法分析上述的代码分别展示了递归和非递归两种排序策略，每一轮排序过后，会返回一个两个子数组的分界点。之后再继续使用新的左右指针位置调用这个函数。先左后右的思路，但是这个是使用的系统的调用栈，如果深度过多容易造成调用栈溢出。所以我们使用非递归的方法，其实就是自己定义一个栈用来模拟调用栈的行为。 非递归的思路如下： 在循环开始前初始化左右两个指针位置分别压栈。 判断栈是否为空，为空则表示排序结束。 不为空时分别按照栈的顺序出栈，使用出栈的指针位置进行一轮排序。 拿到新的基准数位置作为新的指针位置。 如果左右指针位置不相等，分别按照左，右的位置将两个子数组的指针位置进栈，如果相等表示最小的子数组也排序完成，什么都不做。 循环2-5。 最佳情况：O(nlogn) 最坏情况：O(n^2) 平均时间复杂度：O(nlogn) 空间复杂度：O(nlogn) 不稳定排序算法 希尔排序希尔排序是一个改进的插入排序，通过将数组进行分组的方式提高排序的效率，一般我们将数组长度的一半作为初始步长。然后在每一组中按照插入排序的方式进行排序。最后通过不断的缩小步长来进行区域的排序。这种排序方式比直接插入排序的效率高。 算法实现12345678910111213141516171819202122232425//希尔排序void shell_sort(int *array,int length)&#123; int distance = length/2; while(distance&gt;=1) &#123; //整个是一个插入排序 for(int i=distance;i&lt;length;i++)//按照增量分组 &#123; int j=i-distance;//前面的数的位置 int temp=array[i];//将后面的数存一份 while(j&gt;=0 &amp;&amp; temp&lt;array[j])//前面是数不越界且前面的大 &#123; //前面的大数给后面 array[j+distance]=array[j]; //继续向前找当前组的前一个数 j=j-distance; &#125; //排序后把后面的数放在正确的位置 array[j+distance]=temp; &#125; distance=distance/2;//缩小增量，直到为1 &#125;&#125; 算法分析 最佳情况：O(nlogn) 最坏情况：O(nlogn) 平均时间复杂度：O(nlogn) 空间复杂度：O(1) 不稳定排序算法 堆排序什么是堆堆是一个近似与完全二叉树的数据结构。 完全二叉树: 除了最后一层之外的其他每一层都被完全填充，并且所有的节点都保持左对齐。 堆排序就是利用完全二叉数的特性来进行排序的算法分。堆分为最大堆和最小堆。 最大堆要求节点的元素都大于等于其孩子 最小堆要求节点的元素都小于等于其孩子 如何利用数组进行建堆呢？首先要了解数组和堆中节点的对应关系，在堆中是如何表示数组的位置的。根据完全二叉树的特点 array[left] = array[father] * 2 + 1 array[right] = array[father] * 2 +2 如何建立最大堆和最小堆，这里以最大堆为例。从最后的非叶子节点开始，分别和左右孩子进行比较，并将最大的数放置在父节点位置，从后向前，对每一个非叶子节点都进行这种操作，这样每次上层的父节点进行交换的时候保证了他的子节点是比孙子大的。避免了频繁交换的麻烦。这样每次建最大堆都最多交换非叶子节点的个数那么多次。 每建立一次最大堆，就将堆顶的元素取出，表示这里是最大的数，与数组的最后一个位置交换位置，将尾节点交换到根的位置，并将数组的最后一个数剔除出建堆的元素。表示这个数已经排序完成。 算法实现12345678910111213141516171819202122232425262728293031323334//堆排序构建堆函数void adjust(int *array, int length, int index)&#123; int left = 2*index + 1;//左子树 int right = 2*index + 2;//右子树 int maxIndex = index;//定义最大值默认非叶节点 if(left&lt;length &amp;&amp; array[left] &gt; array[maxIndex]) maxIndex = left; //如果左边大，最大的是左边 if(right&lt;length &amp;&amp; array[right] &gt; array[maxIndex]) maxIndex = right; // maxIndex是3个数中最大数的下标 if(maxIndex != index) // 如果maxIndex的值有更新 &#123; int temp = array[maxIndex]; array[index]=array[maxIndex];duiz array[maxIndex]=temp; adjust(array, length, maxIndex); // 递归调整其他不满足堆性质的部分 &#125;&#125;void heap_sort(int *array, int length)&#123; for(int i=length/2 - 1; i &gt;= 0; i--) // 对每一个非叶结点进行堆调整(从最后一个非叶结点开始) &#123; adjust(array, length, i); &#125; for(int i = length - 1; i &gt;= 1; i--) &#123; swap(array[0], array[i]); int temp = array[0]; array[0]=array[i]; array[i]=temp; // 将当前最大的放置到数组末尾 adjust(array, i, 0); // 将未完成排序的部分继续进行堆排序 &#125;&#125; 算法分析 最佳情况：O(nlogn) 最坏情况：O(nlogn) 平均时间复杂度：O(nlogn) 空间复杂度：O(1) 不稳定排序算法 选择排序选择排序的思路非常的简单，符合常人的排序思路，每次从待排序的数组中抽出最小的数放入坑位，如果位置本身就是最小的数，什么都不做。直到待排序数组为空。 算法实现12345678910111213141516171819202122//选择排序，最简单的思路void select_sort(int *array,int length)&#123; //每次从待排序的数组中找到最小的，放在下标的位置，稳定算法（无论是什么样的数组，排序次数不变） for(int i=0;i&lt;length;i++) &#123; int min_index=i; for(int j=i+1;j&lt;length;j++) &#123; if(array[min_index]&gt;array[j]) &#123; min_index=j; &#125; &#125; if(min_index!=i) &#123; int temp=array[i]; array[i]=array[min_index]; array[min_index]=temp; &#125; &#125;&#125; 最佳情况：O(n^2) 最差情况：O(n^2) 平均时间复杂度：O(n^2) 空间复杂度：O(1) 不稳定排序算法 归并排序归并排序采用分治的思想，首先对数组进行划分，直到不能再进行细分，然后将临近的数组进行组合同时排序，使用一个辅助数组，两个子数组的头谁小谁进，直到两个子数组为空，表示合并完成，采用递归的方法，将所有的子数组和并完成的时候数组也就排序完成了。 算法实现123456789101112131415161718192021222324252627282930313233343536373839//归并排序，在两个下标之间合成一个有序序列void merge(int *array,int first,int mid,int last)&#123; int i=first;//第一个子数组首元素 int j=mid+1;//第二个子数组首元素 int m=mid;//第一个子数组尾元素 int n=last;//第二个子数组尾元素 int temp[n];//辅助数组 int k=0;//辅助数组下标 //两个子数组头部，谁小谁进辅助数组,合成一个有序数组 while(i&lt;=m&amp;&amp;j&lt;=n) &#123; if(array[i]&lt;array[j]) temp[k++] = array[i++]; else temp[k++] = array[j++]; &#125; //两个数组有剩余时，直接进辅助数组 while(i&lt;=m) temp[k++]=array[i++]; while(j&lt;=n) temp[k++]=array[j++]; //将辅助数组送回数组 for(i=0;i&lt;k;i++) array[first+i]=temp[i];&#125;// 递归的进行两两分割void merge_sort(int *array,int start,int end)&#123; if(start &lt;end) &#123; int mid=(start+end)/2; merge_sort(array,start,mid);//分割左子数组 merge_sort(array,mid+1,end);//分割右子数组 merge(array,start,mid,end); &#125;&#125; 算法分析 最佳情况：O(nlogn) 最坏情况：O(nlogn) 平均时间复杂度：O(nlogn) 空间复杂度：O(n) 稳定排序算法]]></content>
      <categories>
        <category>算法复习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML类图]]></title>
    <url>%2F2019%2F08%2F05%2FUML%E7%B1%BB%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[类的表示在面向对象的设计方法中，类一般分为三个部分。类名，类属性，和类方法。在面向对象的设计语言中，一个完整的类是需要包含这些方法的。使用类图表示就是下图：Person代表类名，在第一栏，如果是抽象类就用斜体显示。第二栏代表了类的属性，第三栏代表了方法。’+’代表public，’-‘代表private，’#’表示protected。 上图中接口与类图的区别就是顶端有&lt;&lt;interface&gt;&gt;显示。第一栏是接口名称，第二栏列出了接口方法。 类之间的关系类图是面向对象系统建模中最常用和最重要的图，通过画类图可以很清晰的展示系统的设计。类和类之间有六种关系，分别是泛化(Generalization)，实现(Realization)，依赖(Dependency)和关联(Association)，聚合(Aggregation)和组合(Composition)。 虚线箭头指依赖 实线箭头指关联 虚线三角指接口 实线三角指父类 空心菱形是聚合 实心菱形是组合 依赖(Dependency)依赖 是几种关系中耦合度最小的，如下图：氧气类和动物类本身并没有什么关系，只是动物类的某些方法会使用到氧气类，它本身并不是动物类的某个属性，只是某些方法需要使用到而已。具体的代码表现形式就是动物的某个方法需要用到氧气，作为局部变量或者参数。 12345class Animal &#123; public void breath(Oxygen o2)&#123; &#125;&#125; 或者 12345class Animal&#123; public void breath()&#123; Oxygen o2 = new Oxygen(); &#125;&#125; 上述的氧气类对象只是动物类的某个方法持有而不是动物类，只有执行呼吸方法的时候氧气对象才会别初始化，生命周期随方法的结束而结束。 关联(Association) 关联比依赖的耦合度高，一般是一个类是另一个类的一个属性。比如企鹅和气候，企鹅需要知道气候的变换和规律，是和类相关的。气候类伴随着企鹅的生命周期的全过程。具体的代码表现形式就是： 123class Penguin&#123; private Climate climate;&#125; 在企鹅类中，用到了气候对象。 泛化(Generalization)泛化说白了就是某个东西的具体实现，那么在面向对象中就是继承的关系。某个类是父类的具体实现，他们就是泛化关系：泛化就是继承关系，使用实线三角来表示。具体到代码表现就是： 123public class Bird extends Animal&#123;&#125; 实现(Realization)实现表示的是接口。某个类实现了某个接口，使用虚线三角来表示。具体到代码实现是： 123public class WIdeGoose implements Fly&#123;&#125; 组装(Composition)这里为什么要使用组装呢？很多人把组合和聚合分不清楚。组合就是使用不同的零件来组成一件东西。而聚合则是将多个一样的东西合在一起。使用组装则更容易来区分这个概念。组装使用实线菱形来表示。如上图，一只鸟有两只翅膀，是1对2的关系。翅膀是鸟的组成部分之一。具体到代码实现是： 123456class Bird&#123; private Wing wing; public Bird()&#123; wing = new Wing(); &#125;&#125; 在鸟这个对象初始化之时翅膀就要作为鸟初始化的一部分。 聚合(Aggregation)聚合是一种很好理解的关系，我们写代码会经常用到，数组，列表等集合就是聚合关系的表现形式。上图大雁组成雁群，少一只大雁雁群依然是存在的。代码表现形式如下： 123class WideGooseAggregate&#123; private WideGoose[] arrayWideGoose;&#125; 在雁群类中，有大雁的集合对象。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java如何创建一个对象]]></title>
    <url>%2F2019%2F07%2F27%2FJava%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[我们知道Java是面向对象的编码思维，但是你知道一个new语句到底做了什么吗?一个对象到底是如何进行创建，布局和访问的。 对象的创建 第一步，首先虚拟机在在遇到一条new语句的时候，首先会检查这个指令的参数是否能在常量池中定位到一个类的符号引用。并且将检查这个符号引用代表的类是否已经被加载，解析和初始化过。如果没有，则必须对这个类进行类加载。 第二步，类加载完成后，JVM会在java堆上为对象分配内存，内存大小在类加载的时候就已经确定了（这个是如何确定的呢？类加载完成以后，类的继承体系关系就确定了，因为在加载该类之前是要先加载父类的，所以对象的大小=对象头大小+父级继承链非静态成员域大小+当前加载类非静态成员域大小+内存对齐导致的padding。）。从堆中分配内存有两种方式，指针碰撞和空闲列表。 第三步，初始化，将分配的内存区域初始化为零，不同类型有不同的初始化值。保证对象的字段不初始化也可使用。 第四部，执行构造方法，这一步就是执行用户自定义的初始化方法，对数据进行初始化，至此对象创建完成。 指针碰撞和空闲列表指针碰撞如果内存规整，没有碎片，指针碰撞是一个很好的方法。将已使用的内存和未使用的内存分别分布在一个指针的两侧，这个指针就是一个分界点，当需要分配内存的时候，就将指针向空闲的一端移动与内存大小相同的距离。使用的GC搜集器：Serial, ParNew 空闲列表如果内存是不规整的，有大量的碎片存在，JVM就维护一个列表，记录可用的内存块信息，当分配内存的操作发生的时候，就在这个列表中找到一个足够大的内存块分配给对象，并更新表格。使用的GC搜集器：CMS 如何进行选择内存分配方式选择那种分配方式是由Java堆是否规整决定的，而Java堆是否规整又是由所采用的垃圾搜集器是否带有压缩整理算法决定的。同时，还需要考虑对象创建在虚拟机中是非常频繁的行为，需要考虑线程安全的问题，指针碰撞会产生线程之间的冲突，一般解决办法是首先，保证了分配内存操作的原子性，然后预先为每个线程分配一小块内存，保证了他们之间互相不冲突。这块内存叫做本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)。只有该线程用完了TLAB时，才需要同步锁定。虚拟机是否使用TLAB，由选项–XX:+/UseTLAB参数决定。 对象的内存分布对象在内存中分为3个部分，分别是对象头，实例数据，以及对齐填充。 对象头对象头主要分为Mark Word和类型指针。MardWord存储了哈希吗GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID等。这部分数据长度在32、64位虚拟机内分别是32bit和64bit。类型指针指向类元数据的指针，用来确定对象是那一个类的实例。对象头是一个非固定的数据结构。如果对象是一个数组，对象头还要有一块用于记录数组长度的数据。 实例数据实例数据就是对象中定义的数据已经从父类继承的数据。 对齐填充HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，所以必须要使用对齐填充来进行占位。保证对象的大小是8字节的整数倍。 对象的访问定位对象在创建完之后，放在java堆中，但是是如何找到这个对象的呢？分为直接地址和句柄 句柄在java堆中，会划分一个区域叫做句柄池，引用类型reference中存储的就是对象的句柄地址，句柄包含了对象的具体地址信息。移动对象不需要修改数据。 直接地址reference中直接存储对象的地址。速度快。]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Try-with-Resources]]></title>
    <url>%2F2019%2F07%2F24%2FTry-with-Resources%2F</url>
    <content type="text"><![CDATA[Java语法糖是一种在不影响功能的情况下为程序员提供的便捷的语法使用方式。 Tye-with-Resources就是这样一个用来便捷的在try语句块中申请和释放资源的语法使用方式。通过这个语法糖,可以有效的避免在finally中忘记释放资源的情况。类似的思想在Python的with语法中也有体现。推荐一个IDEA插件，sonarlint。通过sonarlint的智能提示，我们可以改正很多的不好的编码习惯。 资源什么是资源，对于非内存的操作，比如磁盘，数据库，比如网络等其他设备。都有一个临界资源的概念。什么是临界资源？在操作系统知识体系中，把一次只能由一个进程使用的资源称为临界资源，所以所有的进程使用这些资源的时候都是互斥的。那么我们在编程的时候，一定要注意临界资源的申请和释放。 try-catch-finally方式传统的资源申请方式是在try中申请，在catch中处理异常，在finally中释放资源。但是程序毕竟是人写的，总会有遗忘的时候。当程序员遗忘后，Java编译器是不会报错的，但是会出bug。try-catch-finally方式如下： 1234567891011121314public static void method()&#123; InputStream inputStream=null; try &#123; inputStream= new FileInputStream("test"); &#125; catch (Exception e) &#123; &#125; finally &#123; try &#123; inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 在上述的代码中，关闭资源的方式非常繁琐。容易遗忘。 try-with-Resources 方法try-with-Resources 是JDK1.7之后的语法糖。旨在简化这种繁琐的关闭资源的方式。代码如下： 123456789//捕获异常public static void try2() &#123; try (BufferedInputStream bin = new BufferedInputStream(new FileInputStream(new File("test.txt"))); BufferedOutputStream bout = new BufferedOutputStream(new FileOutputStream(new File("out.txt")));) &#123; // 执行完try中的语句过后,资源自动关闭 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 在上述的代码中，没有了finally操作，简化了程序员的操作。是一种优雅的编程方式。]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两个有序数组的中位数]]></title>
    <url>%2F2019%2F04%2F30%2F%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例 1:nums1 = [1, 3]nums2 = [2]则中位数是 2.0 示例 2:nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5 思路在两个有序数组中找到中位数还没怎么想过，先回顾一下中位数的定义，一个有序数组，如果是奇数个，中位数是最中间那个数，如果是偶数个，中位数是中间两个数的平均数，拿到题的第一反应是组合成一个有序数组，但是时间复杂度告诉自己不允许这个做。那么还真的必须处理两个有序数组的中位数。为了方便，我们统一将中位数看成（m+n+1)/2和（m+n+2)/2的平均数，如果m+n是奇数，则（m+n+1)/2和（m+n+2)/2是同一个位置。 K是m+n的中间值，如何在两个有序数组中找到K元素呢?，使用i,j来标记两个数组的起始位置。边界条件如下： 某一个数组空白，直接取另一个数组的中位数 K=1，即当两个数组只有一个数字的时候，且取偶数个的左边较小的数字，即比较num1和num2的i，j位置上的数就可以了。 我们使用二分法对数组进行搜索，首先对K二分，分别在num1和num2中查找K/2个单元存在第K/2个数吗？如果存在，取出来，不存在就赋最大值 代码123456789101112131415161718public class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int m = nums1.length, n = nums2.length, left = (m + n + 1) / 2, right = (m + n + 2) / 2; return (findKth(nums1, 0, nums2, 0, left) + findKth(nums1, 0, nums2, 0, right)) / 2.0; &#125; int findKth(int[] nums1, int i, int[] nums2, int j, int k) &#123; if (i &gt;= nums1.length) return nums2[j + k - 1]; if (j &gt;= nums2.length) return nums1[i + k - 1]; if (k == 1) return Math.min(nums1[i], nums2[j]); int midVal1 = (i + k / 2 - 1 &lt; nums1.length) ? nums1[i + k / 2 - 1] : Integer.MAX_VALUE; int midVal2 = (j + k / 2 - 1 &lt; nums2.length) ? nums2[j + k / 2 - 1] : Integer.MAX_VALUE; if (midVal1 &lt; midVal2) &#123; return findKth(nums1, i + k / 2, nums2, j, k - k / 2); &#125; else &#123; return findKth(nums1, i, nums2, j + k / 2, k - k / 2); &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无重复字符的最长子串]]></title>
    <url>%2F2019%2F04%2F27%2F%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1:123输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2:123输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3:1234输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 思路这种字符串题目首先想到的思路是从左向右进行扫描，按照人脑的想法想法一步一步的向后扫，所以我们可以维持一个滑动窗口，每当出现一个重复的字母左界后移，没有就右界后移，每次循环的窗口都进行比较，取最大的数作为结果。 代码123456789101112131415161718192021222324class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; //定义结果 int result = 0; //滑动窗口的左右[i,j) int i=0,j=0; //定义一个Set，保证每个字母只出现一次 Set&lt;Character&gt; set = new HashSet&lt;&gt;(); //防止过界 while(i&lt;s.length() &amp;&amp; j&lt;s.length())&#123; //如果当前字符在set中不存在 if(!set.contains(s.charAt(j)))&#123; //将当前字符加入set并将右界后移 set.add(s.charAt(j++)); //取所有出现窗口的最大值 result = Math.max(result,j-i); &#125;else&#123; //如果出现重复的字符，将左界后移一位 set.remove(s.charAt(i++)); &#125; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两数相加]]></title>
    <url>%2F2019%2F04%2F27%2F%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[题目给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 思路这道题的思路非常简单，因为是链表而且低位是表头，所以直接按照加法的思路，从低位向高位进行进位就成。要对头结点进行操作时，为了避免两个输入链表同时为空，考虑创建哑节点dummy使用dummy-&gt;next表示真正的头节点。 代码123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; //新建哑元节点 ListNode dummy = new ListNode(-1); //从哑元节点后开始作为头结点,游标初始化处于头结点前 ListNode cur = dummy; //进位初始化为0 int carry = 0; //两条链都为零结束循环 while(l1 != null||l2 != null)&#123; //链1节点不为空时值给num1，为空时num1=0， num2同理 int num1 = l1 == null ? 0 : l1.val; int num2 = l2 == null ? 0 : l2.val; //将低位的进位和两个数相加 int sum = num1 + num2 + carry; //大于十则产生进位，carry=1,否则为0 carry = sum &gt;= 10 ? 1 : 0; //处理当前节点，值为个位尾数 cur.next = new ListNode(sum % 10); //游标后移 cur = cur.next; //如果l1不为空,l1后移，l2同理 if(l1 != null) l1 = l1.next; if(l2 != null) l2 = l2.next; &#125; //如果两条链都为零,并且有进位产生，新建一个高位进位节点就行 if (carry == 1) cur.next = new ListNode(1); //返回链，头结点是哑元节点后的节点 return dummy.next; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两数之和]]></title>
    <url>%2F2019%2F04%2F27%2FTwoSum%2F</url>
    <content type="text"><![CDATA[坚持就是胜利，开始刷题之旅 题目给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例:12345给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 思路读懂这道题后的第一反应就是暴力向后搜索。但是这样的复杂度是O(n^2),肯定没有这么简单。只能通过空间来换时间，那么有什么查询方式是O(1)呢？第一反应是散列查找，也就是哈希查找。在java中。有HashMap类可以实现这个需求，那么代码可以是这个样子 代码解法一1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; //初始化一个int对应int的hashmap HashMap&lt;Integer, Integer&gt; m = new HashMap&lt;Integer, Integer&gt;(); //初始化结果数组 int[] res = new int[2]; //将题目给定的数组放入hashmap中 for (int i = 0; i &lt; nums.length; i++) &#123; m.put(nums[i], i); &#125; //开始搜索 for (int i = 0; i &lt; nums.length; i++) &#123; //搜索值等于和减去当前值 int t = target - nums[i]; //在hashmap中搜索并且保证存在而且不等于当前值 if (m.containsKey(t) &amp;&amp; m.get(t) != i) &#123; //对结果进行赋值，搜索到所以退出搜索 res[0] = i; res[1] = m.get(t); break; &#125; &#125; return res; &#125;&#125;; 提交上述代码，会发现内存消耗很大，时间也只是9ms超过了80%的人。一定有更优的解法。百度后发现可以将两个操作合二为一。上述解法先是将数组放入hashmap中，然后再进行查找。可不可以边放边找呢？先全部放入就是拿到前面的数去找后面的数。边放边找就是拿着后面的数去找前面的数。仔细想想，确实是这个道理。那么试试？？ 解法二123456789101112131415161718192021class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; //初始化一个int对应int的hashmap HashMap&lt;Integer, Integer&gt; m = new HashMap&lt;Integer, Integer&gt;(); //初始化结果数组 int[] res = new int[2]; //开始查找 for (int i = 0; i &lt; nums.length; i++) &#123; //如果hashmap中存在和减去当前数的数字 if(m.containsKey(target - nums[i]))&#123; //赋值，表示查找到，用后数找前数，所以需要换一下位置 res[1]=i; res[0]=m.get(target - nums[i]); break; &#125; //关键，每次循环都要放一个数到hashmap中，在查找中，拿着前数总是找不到后数的，因为还没有放进去，但是总会循环到后数，拿着后数的时候，前数已经放进去了，总是能找到的。所以这个方法很精妙，没有问题。 m.put(nums[i], i); &#125; return res; &#125;&#125; 上述方法快了1ms,内存消耗也少了。]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存区域]]></title>
    <url>%2F2019%2F04%2F23%2FJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[Java内存分布虽然对于入门的Java初学者来说是透明的，上课念PPT的老师也永远不会跟你提及这些概念，顶多在继承封装多态上让你背一些概念性的东西，但是都说知其然知其所以然，作为Java虚拟机知识体系基础的Java内存是如何进行管理的呢？理解了Java虚拟机的运行原理，对于排除代码BUG和程序性能优化有非常大的好处 程序计数器类似于CPU内部的PC寄存器，保存着字节码指令地址．程序需要通过程序计数器的值来选取下一条需要执行的字节码指令．程序的分支，跳转，循环，异常处理，线程恢复都得靠程序计数器来完成．程序计数器保证了JAVA各线程执行时的井然有序，所以是线程私有的，各个线程独立存储． 如果执行的是Java方法，程序计数器存储的是正在执行的字节码指令的地址 如果正在执行的是Native方法，程序计数器为空(Undefined) 此内存区域是唯一一个没有规定任何OutOfMemoryError情况的区域 Java虚拟机栈Java虚拟机栈同样是线程私有的，是方法执行时的结构．描述的是方法执行时的内存模型．每个方法执行时都会创建栈帧，用于存储方法的信息．方法的调用和返回过程，对应着栈帧的入栈和出栈过程 栈帧包含信息包括局部变量表，操作数栈，动态链接，和方法的返回地址 如果线程请求的栈深度超过了虚拟机允许的深度，会抛出StackOverflowError异常，如果允许动态扩展的栈在扩展时无法申请到足够的内存，会抛出OutOfMemoryError异常。 局部变量表简介局部变量表存放方法参数和方法内部局部变量。在编译成Class文件时，在方法的Code属性中的max_locals数据项中就确定了该方法局部变量表的最大容量，局部变量表以变量槽（Slot）为最小单位。详细内容会再进行专门介绍。 操作数栈简介操作数栈是一个后进先出的栈结构，最大深度在编译时写入Code属性中的max_stacks数据项中。方法开始执行时为空，方法内部的算术运算或者调用其他方法的时候就是通过操作数栈来进行参数传递的。与汇编语言中的CPU栈概念模型类似。 动态链接简介每个栈帧都包含指向运行时常量池中该栈帧所属方法的引用，Class文件的常量池中存在大量的符号引用，字节码中方法调用指令就以常量池中指向方法的符号引用作为参数。 在类加载阶段转化为直接引用，这种转化成为静态解析。 在每一次运行期间转化为直接引用，这部分成为动态链接。 方法返回地址简介方法一定是会执行完成的。有两种方式结束方法的执行。一是正常结束，调用者的PC计数器的值可以作为返回地址。二是异常退出，返回地址通过异常处理器表来完成。 方法退出等同于把当前栈帧出栈。可能执行的操作有，恢复上层方法的局部变量表和操作数栈，将返回值写入调用者栈帧的操作数栈，调整PC计数器的值指向方法调用指令的后一条。 本地方法栈本地方法栈与虚拟机栈发挥作用相似，其中执行的是虚拟机使用到的Native方法。各个虚拟机可能会不同，Sun HotSpot虚拟机就直接将本地方法栈和虚拟机栈合二为一。与虚拟机栈相同，本地方法栈也会抛出StackOverflowError和OutMemoryError异常。 Java堆Java堆是所有new对象的存储地，是Java虚拟机所管理内存中最大的一块。后续将要学习的内存回收算法就是与这块内存有关的。Java堆是所有线程共享的内存区域。Java虚拟机规范描述：所有的对象实例以及数组都要在堆上进行分配。 Java堆是GC管理的主要区域，可以细分为新生代，老年代。新生代是那种频繁被创建和销毁的对象的存放地，可能每次进行垃圾收集时就会有大批量的对象被清除。老年代的对象则存活率高，新生代的对象如果达到了老年代的标准，也会被划分到老年代，大对象创建时也会直接分配到老年代。具体细节会在GC回收中再总结。 方法区方法区和堆一样也是线程共享的区域。用于存储已经被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据，比如spring 使用IOC或者AOP创建bean时，或者使用cglib，反射的形式动态生成class信息等）。Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不进行垃圾搜集。这个区域的垃圾搜集行为比较少见。方法区不够大时，会抛出OutOfMemoryError异常。类信息如下，详细内容会在Java类加载机制中介绍。 类信息 类型全限定名。 类型的直接超类的全限定名（除非这个类型是java.lang.Object，它没有超类）。 类型是类类型还是接口类型。 类型的访问修饰符（public、abstract或final的某个子集）。 任何直接超接口的全限定名的有序列表。 类型的常量池。 字段信息。 方法信息。 除了常量意外的所有类（静态）变量。 一个到类ClassLoader的引用。 一个到Class类的引用。 运行时常量池Class文件中有一项信息存储编译期生成的各种字面量和符号引用，也就是常量池，这部分内容在类加载后会进入方法区的运行时常量池存放。运行时常量池具有动态性，并不要求运行时常量池严格和Class文件中的常量池内容一致，运行期间也能将新的常量放入池中，比如String类的intern()方法. 运行时常量池隶属于方法区，同样在内存不够大时抛出OutOfMemory异常。]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java虚拟机</tag>
      </tags>
  </entry>
</search>
